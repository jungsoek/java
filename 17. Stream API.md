# 17. Stream API

## `Stream` ìƒì„± ë° ê°€ê³µ

### âœ… 1. Stream ìƒì„± ë°©ë²•

Javaì—ì„œ Streamì„ ìƒì„±í•˜ëŠ” ë°©ë²•ì€ ë§¤ìš° ë‹¤ì–‘í•˜ë©°, ëŒ€í‘œì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ë‹¤:

#### ğŸ”¹ ì»¬ë ‰ì…˜ ê¸°ë°˜ ìƒì„±

```
List<String> list = List.of("A", "B", "C");
Stream<String> stream = list.stream();
```

#### ğŸ”¹ ë°°ì—´ ê¸°ë°˜ ìƒì„±

```
String[] array = {"A", "B", "C"};
Stream<String> stream = Arrays.stream(array);
```

#### ğŸ”¹ Stream.of()

```
Stream<Integer> stream = Stream.of(1, 2, 3, 4);
```

#### ğŸ”¹ Stream.builder()

```
Stream<String> stream = Stream.<String>builder()
    .add("A").add("B").add("C")
    .build();
```

#### ğŸ”¹ ë¬´í•œ ìŠ¤íŠ¸ë¦¼ (iterate, generate)

```
Stream<Integer> infinite = Stream.iterate(0, n -> n + 2); // ì§ìˆ˜ ë¬´í•œ
Stream<Double> randoms = Stream.generate(Math::random);   // ë¬´ì‘ìœ„ ë¬´í•œ
```

> ë¬´í•œ ìŠ¤íŠ¸ë¦¼ì€ `.limit(n)`ìœ¼ë¡œ ì œí•œí•´ì„œ ì‚¬ìš©í•´ì•¼ í•¨

------

### âœ… 2. ì¤‘ê°„ ì—°ì‚° (Intermediate Operations)

ì¤‘ê°„ ì—°ì‚°ì€ **ë°ì´í„°ë¥¼ ê°€ê³µí•˜ê±°ë‚˜ í•„í„°ë§í•˜ê±°ë‚˜ ì •ë ¬í•˜ê±°ë‚˜ ë³€ê²½**í•˜ëŠ” ì—°ì‚°ì´ë‹¤.
 ğŸ’¡ *Stream ìì²´ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ ì²´ì´ë‹ì´ ê°€ëŠ¥í•˜ë‹¤.*

#### ğŸ“Œ filter(Predicate)

```
stream.filter(s -> s.startsWith("A"))
```

ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë§Œ í†µê³¼

------

#### ğŸ“Œ map(Function)

```
stream.map(String::toLowerCase)
```

ê°’ì„ ë³€í™˜ â†’ `"A"` â†’ `"a"` ë“±

------

#### ğŸ“Œ flatMap(Function)

```
Stream<String> lines = Stream.of("a b", "c d");
Stream<String> words = lines.flatMap(line -> Arrays.stream(line.split(" ")));
```

`Stream<Stream<T>>` â†’ `Stream<T>` í‰íƒ„í™”

------

#### ğŸ“Œ distinct()

```
stream.distinct()
```

ì¤‘ë³µ ì œê±°

------

#### ğŸ“Œ sorted(), sorted(Comparator)

```
stream.sorted()
stream.sorted(Comparator.reverseOrder())
```

ê¸°ë³¸ ì •ë ¬ or ì‚¬ìš©ì ì •ì˜ ì •ë ¬

------

#### ğŸ“Œ peek(Consumer)

```
stream.peek(System.out::println)
```

ì¤‘ê°„ í™•ì¸ìš© ë””ë²„ê¹… (side-effectë§Œ ê°€ëŠ¥)

------

#### ğŸ“Œ limit(n), skip(n)

```
stream.limit(5) // ì•ì—ì„œ 5ê°œë§Œ
stream.skip(3)  // ì•ì—ì„œ 3ê°œ ê±´ë„ˆëœ€
```

------

### âœ… 3. ìµœì¢… ì—°ì‚° (Terminal Operations)

ìµœì¢… ì—°ì‚°ì€ Stream ì²˜ë¦¬ë¥¼ ì¢…ë£Œí•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.

| ì—°ì‚°                                      | ì„¤ëª…                       |
| ----------------------------------------- | -------------------------- |
| `forEach(Consumer)`                       | ìš”ì†Œ ìˆœíšŒ                  |
| `collect(Collectors)`                     | List, Set, Map ë“±ìœ¼ë¡œ ìˆ˜ì§‘ |
| `reduce(BinaryOperator)`                  | ëˆ„ì  ì—°ì‚°                  |
| `count()`                                 | ê°œìˆ˜ ë°˜í™˜                  |
| `min()`, `max()`                          | ìµœì†Œ/ìµœëŒ€ê°’                |
| `anyMatch()`, `allMatch()`, `noneMatch()` | ì¡°ê±´ ë§Œì¡± ì—¬ë¶€             |
| `findFirst()`, `findAny()`                | ìš”ì†Œ ë°˜í™˜ (Optional)       |

------

### âœ… 4. ì‹¤ì „ ì˜ˆì‹œ

```
List<String> names = List.of("Kim", "Lee", "Park", "Kang", "Kim");

List<String> result = names.stream()
    .filter(n -> !n.equals("Kim"))
    .map(String::toUpperCase)
    .distinct()
    .sorted()
    .collect(Collectors.toList());

System.out.println(result); // [KANG, LEE, PARK]
```

------

### ğŸ§  ìš”ì•½ ì •ë¦¬í‘œ

| ëª©ì         | ë©”ì„œë“œ                                | ì˜ˆì‹œ                                 |
| ----------- | ------------------------------------- | ------------------------------------ |
| Stream ìƒì„± | `stream()`, `of()`, `Arrays.stream()` | `List.of(1,2,3).stream()`            |
| í•„í„°ë§      | `filter(Predicate)`                   | `.filter(x -> x > 0)`                |
| ë³€í™˜        | `map(Function)`                       | `.map(String::length)`               |
| í‰íƒ„í™”      | `flatMap(Function)`                   | `.flatMap(...)`                      |
| ì •ë ¬        | `sorted()`                            | `.sorted(Comparator.reverseOrder())` |
| ì¤‘ë³µ ì œê±°   | `distinct()`                          | `.distinct()`                        |
| ì¼ë¶€ë§Œ ì¶”ì¶œ | `limit(n)`, `skip(n)`                 | `.limit(5)`                          |
| ìµœì¢… ì²˜ë¦¬   | `forEach`, `collect`, `reduce`        | `.collect(Collectors.toList())`      |

## ì¤‘ê°„ ì—°ì‚°: `filter`, `map`, `distinct`, `sorted`

### ğŸŸ¦ 1. `filter(Predicate<T>)`

**ì„¤ëª…**: ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ê³¨ë¼ëƒ„ (boolean ë°˜í™˜í•˜ëŠ” ëŒë‹¤ í•„ìš”)

#### ğŸ“Œ ê¸°ë³¸ í˜•íƒœ:

```
Stream<T> filter(Predicate<? super T> predicate)
```

#### ğŸ“Œ ì˜ˆì‹œ:

```
List<String> names = List.of("Alice", "Bob", "Angela", "David");

names.stream()
     .filter(name -> name.startsWith("A"))
     .forEach(System.out::println);
// ì¶œë ¥: Alice, Angela
```

#### ğŸ” ë‚´ë¶€ì ìœ¼ë¡œ

`filter`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `boolean test(T t)` ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” `Predicate` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì´ìš©í•´ì„œ ì¡°ê±´ì„ í‰ê°€í•´. `true`ë©´ streamì— ë‚¨ê³ , `false`ë©´ ì œì™¸ë¨.

------

### ğŸŸ¨ 2. `map(Function<T, R>)`

**ì„¤ëª…**: ê° ìš”ì†Œë¥¼ **ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ë³€í™˜**í•¨. (ì˜ˆ: ëŒ€ë¬¸ìë¡œ, ê¸¸ì´ë¡œ, ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ)

#### ğŸ“Œ ê¸°ë³¸ í˜•íƒœ:

```
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

#### ğŸ“Œ ì˜ˆì‹œ:

```
List<String> names = List.of("Alice", "Bob");

names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);
// ì¶œë ¥: ALICE, BOB
```

ë˜ëŠ”

```
List<String> names = List.of("Apple", "Banana", "Carrot");

names.stream()
     .map(String::length)
     .forEach(System.out::println);
// ì¶œë ¥: 5, 6, 6
```

#### ğŸ” ë‚´ë¶€ì ìœ¼ë¡œ

`map`ì€ `Function<T, R>`ì„ ì´ìš©í•´ì„œ ê° ìš”ì†Œì— ë³€í™˜ í•¨ìˆ˜ë¥¼ ì ìš©í•œ ë‹¤ìŒ, ìƒˆë¡œìš´ Stream<R>ì„ ë§Œë“¤ì–´ ë°˜í™˜í•´.

------

### ğŸŸ© 3. `distinct()`

**ì„¤ëª…**: ì¤‘ë³µì„ ì œê±°í•œ Stream ë°˜í™˜ (equals/hashCode ê¸°ì¤€)

#### ğŸ“Œ ê¸°ë³¸ í˜•íƒœ:

```
Stream<T> distinct()
```

#### ğŸ“Œ ì˜ˆì‹œ:

```
List<Integer> nums = List.of(1, 2, 2, 3, 3, 3, 4);

nums.stream()
    .distinct()
    .forEach(System.out::println);
// ì¶œë ¥: 1, 2, 3, 4
```

#### ğŸ” ë‚´ë¶€ì ìœ¼ë¡œ

`distinct()`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `HashSet`ì„ ì‚¬ìš©í•˜ì—¬ `equals()`ì™€ `hashCode()` ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µì„ ê±¸ëŸ¬ëƒ„. ë”°ë¼ì„œ ì„±ëŠ¥ì€ O(n) ì •ë„ì§€ë§Œ, ê°ì²´ì˜ `equals`, `hashCode` êµ¬í˜„ì— ë”°ë¼ ë™ì‘ì´ ë‹¬ë¼ì§.

------

### ğŸŸ¥ 4. `sorted()` / `sorted(Comparator)`

**ì„¤ëª…**: ìš”ì†Œë¥¼ ì •ë ¬í•˜ì—¬ ìƒˆë¡œìš´ Streamì„ ìƒì„±

- ê¸°ë³¸ ì •ë ¬: `Comparable` ì¸í„°í˜ì´ìŠ¤ ê¸°ì¤€
- ì‚¬ìš©ì ì •ë ¬: `Comparator<T>` ì „ë‹¬

#### ğŸ“Œ ê¸°ë³¸ í˜•íƒœ:

```
Stream<T> sorted() // ìì—° ìˆœì„œ
Stream<T> sorted(Comparator<? super T> comparator)
```

#### ğŸ“Œ ì˜ˆì‹œ 1: ê¸°ë³¸ ì •ë ¬

```
List<Integer> nums = List.of(5, 3, 9, 1);

nums.stream()
    .sorted()
    .forEach(System.out::println);
// ì¶œë ¥: 1, 3, 5, 9
```

#### ğŸ“Œ ì˜ˆì‹œ 2: ì—­ìˆœ ì •ë ¬

```
nums.stream()
    .sorted(Comparator.reverseOrder())
    .forEach(System.out::println);
// ì¶œë ¥: 9, 5, 3, 1
```

#### ğŸ“Œ ì˜ˆì‹œ 3: ê°ì²´ ì •ë ¬

```
List<String> names = List.of("Kim", "Lee", "Park");

names.stream()
     .sorted((a, b) -> b.length() - a.length())
     .forEach(System.out::println);
// ì¶œë ¥: "Park", "Kim", "Lee"
```

------

### ğŸ§  ìš”ì•½ ë¹„êµí‘œ

| ì—°ì‚°       | ì¸í„°í˜ì´ìŠ¤                   | ì£¼ìš” ìš©ë„   |
| ---------- | ---------------------------- | ----------- |
| `filter`   | `Predicate<T>`               | ì¡°ê±´ í•„í„°ë§ |
| `map`      | `Function<T, R>`             | ê°’ ë³€í™˜     |
| `distinct` | ë‚´ë¶€ equals/hashCode ì‚¬ìš©    | ì¤‘ë³µ ì œê±°   |
| `sorted`   | `Comparable` or `Comparator` | ì •ë ¬        |

------

### ğŸ’¡ ì‹¤ì „ ì˜ˆì œ: 4ê°œ ì¡°í•©

```
List<String> words = List.of("apple", "banana", "apple", "cherry", "banana", "date");

words.stream()
     .filter(w -> w.length() > 5)           // ê¸¸ì´ 6 ì´ìƒ
     .map(String::toUpperCase)              // ëŒ€ë¬¸ì ë³€í™˜
     .distinct()                            // ì¤‘ë³µ ì œê±°
     .sorted()                              // ì•ŒíŒŒë²³ ì •ë ¬
     .forEach(System.out::println);

// ì¶œë ¥:
// BANANA
// CHERRY
```

## ìµœì¢… ì—°ì‚°: `forEach`, `collect`, `reduce`, `count`

### âœ… 1. `forEach(Consumer<T>)`

**ì„¤ëª…**: ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í•¨ (ì¶œë ¥, ì €ì¥ ë“± ë¶€ìˆ˜ íš¨ê³¼(side effect)ìš©)

#### ğŸ“Œ ê¸°ë³¸ êµ¬ì¡°

```
void forEach(Consumer<? super T> action)
```

#### ğŸ“Œ ì˜ˆì œ

```
List<String> list = List.of("A", "B", "C");
list.stream().forEach(System.out::println);
// ì¶œë ¥: A B C
```

#### âš ï¸ ì£¼ì˜

- ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•ŠìŒ â†’ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼(parallelStream)ì—ì„œëŠ” íŠ¹íˆ ì£¼ì˜
- ë¶€ì‘ìš©(side-effect)ì—ë§Œ ì‚¬ìš©í•˜ê³  Stream ë‚´ë¶€ ë¡œì§ì—ëŠ” ì˜í–¥ ì—†ìŒ

------

### âœ… 2. `collect(Collector<T, A, R>)`

**ì„¤ëª…**: ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ **ì»¬ë ‰ì…˜(List, Set, Map)** ìœ¼ë¡œ ëª¨ìœ¼ê±°ë‚˜, í†µê³„ë¥¼ ë‚´ê±°ë‚˜, ë¬¸ìì—´ë¡œ í•©ì¹˜ê±°ë‚˜ ë“± ë‹¤ì–‘í•œ ê²°ê³¼ë¡œ ìˆ˜ì§‘

#### ğŸ“Œ ê°€ì¥ ìì£¼ ì“°ëŠ” Collectors

```
Collectors.toList()
Collectors.toSet()
Collectors.toMap()
Collectors.joining()
Collectors.counting()
Collectors.averagingInt()
Collectors.groupingBy()
Collectors.partitioningBy()
```

#### ğŸ“Œ ì˜ˆì œ 1: Listë¡œ ìˆ˜ì§‘

```
List<String> upper = List.of("a", "b", "c")
    .stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

#### ğŸ“Œ ì˜ˆì œ 2: Mapìœ¼ë¡œ ìˆ˜ì§‘

```
Map<String, Integer> map = List.of("a", "bb", "ccc")
    .stream()
    .collect(Collectors.toMap(s -> s, String::length));
// ê²°ê³¼: {"a":1, "bb":2, "ccc":3}
```

------

### âœ… 3. `reduce()` â€” ëˆ„ì‚° ì—°ì‚°

**ì„¤ëª…**: ëª¨ë“  ìš”ì†Œë¥¼ í•˜ë‚˜ì˜ ê²°ê³¼ê°’ìœ¼ë¡œ ì¤„ì—¬ë‚˜ê°€ëŠ” ì—°ì‚° (í•©ê³„, ê³±, ìµœëŒ“ê°’ ë“±)

#### ğŸ“Œ ê¸°ë³¸ êµ¬ì¡°

```
Optional<T> reduce(BinaryOperator<T> accumulator)
T reduce(T identity, BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) // ë³‘ë ¬
```

#### ğŸ“Œ ì˜ˆì œ 1: í•©ê³„ êµ¬í•˜ê¸°

```
int sum = List.of(1, 2, 3, 4)
    .stream()
    .reduce(0, (a, b) -> a + b);
// ê²°ê³¼: 10
```

#### ğŸ“Œ ì˜ˆì œ 2: ê°€ì¥ ê¸´ ë¬¸ìì—´

```
Optional<String> longest = List.of("a", "bbb", "cc")
    .stream()
    .reduce((s1, s2) -> s1.length() > s2.length() ? s1 : s2);
// ê²°ê³¼: Optional["bbb"]
```

------

### âœ… 4. `count()`

**ì„¤ëª…**: ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ê°œìˆ˜ ë°˜í™˜ (`long`)

#### ğŸ“Œ ì˜ˆì œ

```
long cnt = List.of(1, 2, 3, 4, 5)
    .stream()
    .filter(n -> n % 2 == 0)
    .count();
// ê²°ê³¼: 2 (2ì™€ 4)
```

------

### ğŸ§  ìš”ì•½ ì •ë¦¬í‘œ

| ì—°ì‚°      | ì„¤ëª…                           | ë°˜í™˜ íƒ€ì…        | ì˜ˆì‹œ                            |
| --------- | ------------------------------ | ---------------- | ------------------------------- |
| `forEach` | ìš”ì†Œë§ˆë‹¤ ì‘ì—… ìˆ˜í–‰             | void             | ì¶œë ¥, side-effect               |
| `collect` | ë¦¬ìŠ¤íŠ¸, ë§µ, ë¬¸ìì—´ ë“±ìœ¼ë¡œ ìˆ˜ì§‘ | List, Map ë“±     | `.collect(Collectors.toList())` |
| `reduce`  | ëˆ„ì  ê³„ì‚°                      | Optional<T> or T | í•©ê³„, ìµœëŒ€, ê³±                  |
| `count`   | ê°œìˆ˜ ê³„ì‚°                      | long             | `.count()`                      |

------

### ğŸ§ª ì‹¤ì „ ì˜ˆì œ: ì¡°í•©

```
List<String> names = List.of("Kim", "Lee", "Park", "Kim", "Choi");

long uniqueK = names.stream()
    .filter(n -> n.startsWith("K"))
    .distinct()
    .count();

System.out.println("Kë¡œ ì‹œì‘í•˜ëŠ” ê³ ìœ  ì´ë¦„ ê°œìˆ˜: " + uniqueK);
// ì¶œë ¥: Kë¡œ ì‹œì‘í•˜ëŠ” ê³ ìœ  ì´ë¦„ ê°œìˆ˜: 1
```

## ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ (`parallelStream()`)

### âœ… ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ (`parallelStream()`) ì´ë€?

- ì¼ë°˜ ìŠ¤íŠ¸ë¦¼(`stream()`)ì€ **ë‹¨ì¼ ìŠ¤ë ˆë“œ**ë¡œ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬ë¨
- `parallelStream()`ì€ ë‚´ë¶€ì ìœ¼ë¡œ **ForkJoinPoolì˜ ê³µìš© ìŠ¤ë ˆë“œí’€**ì„ í™œìš©í•´ì„œ ë³‘ë ¬ ì²˜ë¦¬í•¨
- ì—°ì‚°ì˜ ë³‘ë ¬ì„±ì„ **ê°œë°œìê°€ ì§ì ‘ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„** ìë™ìœ¼ë¡œ ë³‘ë ¬í™”ë¨

------

### ğŸ”¹ ì‚¬ìš©ë²• ë¹„êµ

```
List<Integer> list = IntStream.rangeClosed(1, 10_000_000)
    .boxed()
    .collect(Collectors.toList());

// ìˆœì°¨ ì²˜ë¦¬
long time1 = System.currentTimeMillis();
int sum1 = list.stream().mapToInt(i -> i).sum();
System.out.println("ìˆœì°¨ ì²˜ë¦¬: " + (System.currentTimeMillis() - time1) + "ms");

// ë³‘ë ¬ ì²˜ë¦¬
long time2 = System.currentTimeMillis();
int sum2 = list.parallelStream().mapToInt(i -> i).sum();
System.out.println("ë³‘ë ¬ ì²˜ë¦¬: " + (System.currentTimeMillis() - time2) + "ms");
```

------

### âœ… íŠ¹ì§• ë° ë‚´ë¶€ ë™ì‘

| í•­ëª©          | ì„¤ëª…                                                         |
| ------------- | ------------------------------------------------------------ |
| ë‚´ë¶€ ìŠ¤ë ˆë“œí’€ | `ForkJoinPool.commonPool()` ì‚¬ìš© (ê¸°ë³¸ì ìœ¼ë¡œ CPU ì½”ì–´ ìˆ˜ í™œìš©) |
| ìŠ¤ë ˆë“œ ê´€ë¦¬   | ê°œë°œìê°€ ì§ì ‘ ìŠ¤ë ˆë“œë¥¼ ë‹¤ë£¨ì§€ ì•ŠìŒ                           |
| ë™ì‘ ë°©ì‹     | ë°ì´í„°ë¥¼ ë¶„í•  â†’ ë³‘ë ¬ ì²˜ë¦¬ â†’ ê²°ê³¼ ë³‘í•©                        |
| ë‹¨ì           | ìŠ¤ë ˆë“œê°„ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ë¹„ìš© ë°œìƒ, ê²°ê³¼ ìˆœì„œ ë³´ì¥ ì•ˆ ë¨     |
| ì£¼ì˜          | ë³‘ë ¬í™”ì— ì˜¤íˆë ¤ ì‹œê°„ì´ ë” ê±¸ë¦´ ìˆ˜ë„ ìˆìŒ (ì‘ì€ ë°ì´í„°, ì‚¬ì´ë“œ ì´í™íŠ¸ ìˆì„ ë•Œ) |

------

### âš ï¸ ì–¸ì œ `parallelStream()`ì„ ì“°ë©´ ì•ˆ ë˜ëŠ”ê°€?

- **ì…ì¶œë ¥(IO)** ì„ í¬í•¨í•˜ëŠ” ì—°ì‚° (ë””ìŠ¤í¬, ë„¤íŠ¸ì›Œí¬ ë“±): ë³‘ë ¬ì„±ì´ íš¨ê³¼ ì—†ìŒ
- **ì‚¬ì´ë“œ ì´í™íŠ¸**ê°€ ìˆëŠ” ì—°ì‚°: `forEach`ì—ì„œ íŒŒì¼ ì €ì¥, ì½˜ì†” ì¶œë ¥ ë“±
- **ìˆœì„œê°€ ì¤‘ìš”í•œ ì—°ì‚°**: `.forEachOrdered()` ëŒ€ì‹  `.forEach()`ëŠ” ìˆœì„œ ë³´ì¥ X
- **ì‘ì€ ë°ì´í„°ì…‹**: ë³‘ë ¬ ì²˜ë¦¬ ì˜¤ë²„í—¤ë“œê°€ ë” í´ ìˆ˜ ìˆìŒ

------

### âœ… ì˜ˆì œ: ì„±ëŠ¥ ì°¨ì´ ì²´ê°

```
List<Integer> big = IntStream.rangeClosed(1, 100_000_000)
    .boxed()
    .collect(Collectors.toList());

long seq = System.currentTimeMillis();
long count1 = big.stream().filter(n -> n % 2 == 0).count();
System.out.println("ìˆœì°¨: " + (System.currentTimeMillis() - seq) + "ms");

long par = System.currentTimeMillis();
long count2 = big.parallelStream().filter(n -> n % 2 == 0).count();
System.out.println("ë³‘ë ¬: " + (System.currentTimeMillis() - par) + "ms");
```

> ğŸ’¡ ì‹¤í–‰ í™˜ê²½ì— ë”°ë¼ **ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì´ í›¨ì”¬ ë¹ ë¥´ê±°ë‚˜ ì˜¤íˆë ¤ ëŠë¦´ ìˆ˜ ìˆìŒ** â†’ ì‹¤í—˜ í•„ìš”

------

### âœ… `.parallel()` vs `.parallelStream()`

```
stream().parallel();        // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ì„ ë³‘ë ¬í™”
parallelStream();           // ì²˜ìŒë¶€í„° ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ìƒì„±
```

```
list.stream().parallel()
    .map(...)
    .forEach(...);
```

â†’ **ë™ì¼í•œ íš¨ê³¼**, ë‹¨ `stream()`ìœ¼ë¡œ ì‹œì‘í•  ê²½ìš° ë³‘ë ¬ ì—¬ë¶€ë¥¼ ë‚˜ì¤‘ì— ì œì–´í•  ìˆ˜ ìˆìŒ

------

### ğŸ§  ìš”ì•½ ì •ë¦¬í‘œ

| ë©”ì„œë“œ                            | ì„¤ëª…                                                    |
| --------------------------------- | ------------------------------------------------------- |
| `parallelStream()`                | ì»¬ë ‰ì…˜ ê¸°ë°˜ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ì‹œì‘                            |
| `stream().parallel()`             | ê¸°ì¡´ ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ì„ ë³‘ë ¬ë¡œ ì „í™˜                          |
| `forEach()` vs `forEachOrdered()` | ë³‘ë ¬ì—ì„œëŠ” `forEachOrdered()`ë§Œ ìˆœì„œ ë³´ì¥               |
| ë³‘ë ¬ì²˜ë¦¬ ëŒ€ìƒ                     | CPU ë°”ìš´ë“œ ì‘ì—…(ê³„ì‚° ì¤‘ì‹¬)ì— íš¨ê³¼ì                      |
| ë¹„ì¶”ì²œ ì‚¬ë¡€                       | I/O ì‘ì—…, ì‘ì€ ì»¬ë ‰ì…˜, ìˆœì„œ ë¯¼ê° ì—°ì‚°, side-effect í¬í•¨ |

------

### ğŸš§ ê³ ê¸‰ í™œìš©: ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ì»¤ìŠ¤í„°ë§ˆì´ì§•

```
ForkJoinPool customPool = new ForkJoinPool(4);
customPool.submit(() -> {
    list.parallelStream().forEach(System.out::println);
}).get();
```

â†’ `ForkJoinPool.commonPool()` ëŒ€ì‹  **ì‚¬ìš©ì ì •ì˜ ìŠ¤ë ˆë“œí’€**ì„ ì ìš©í•  ìˆ˜ ìˆìŒ (ì£¼ì˜: ë™ê¸°í™” ë¬¸ì œ ë°œìƒ ê°€ëŠ¥)