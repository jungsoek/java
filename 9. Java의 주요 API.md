# 9. Java의 주요 API (중간 수준 목차)

# 9.1 `java.lang`

## Object, String, Math, System, Class 등 핵심 클래스

### 🔷 1. `Object` 클래스

#### 🌟 개요

- 자바의 **모든 클래스의 최상위 부모 클래스** (모든 클래스는 암묵적으로 `Object`를 상속받음)
- 모든 객체는 최소한 `Object`의 메서드를 상속받는다.

#### 🧩 주요 메서드

| 메서드                              | 설명                                   |
| ----------------------------------- | -------------------------------------- |
| `toString()`                        | 객체의 문자열 표현 반환                |
| `equals(Object obj)`                | 두 객체의 동등성 비교                  |
| `hashCode()`                        | 객체의 해시코드 반환                   |
| `getClass()`                        | 객체의 클래스 정보를 반환              |
| `clone()`                           | 객체 복제                              |
| `finalize()`                        | GC 직전에 호출되는 메서드 (Deprecated) |
| `wait()`, `notify()`, `notifyAll()` | 동기화(스레드) 관련 제어용 메서드      |

#### ✅ 예시

```
class Person {
    String name;
    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person: " + name;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Person p) {
            return this.name.equals(p.name);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("John");
        Person p2 = new Person("John");

        System.out.println(p1);              // Person: John
        System.out.println(p1.equals(p2));   // true
        System.out.println(p1.hashCode());   // 동일한 이름이면 동일 해시
    }
}
```

------

### 🔷 2. `String` 클래스

#### 🌟 개요

- **불변 객체 (immutable)**: 한 번 생성된 문자열은 수정 불가.
- 문자열 리터럴은 **String Constant Pool**에 저장됨.
- 문자열 조작은 `+`, `substring()`, `indexOf()` 등으로 수행.

#### 🧩 주요 메서드

| 메서드                                     | 설명                    |
| ------------------------------------------ | ----------------------- |
| `length()`                                 | 문자열 길이 반환        |
| `charAt(int)`                              | 인덱스 위치의 문자 반환 |
| `substring()`                              | 부분 문자열 반환        |
| `equals()`                                 | 문자열 비교             |
| `contains()`, `startsWith()`, `endsWith()` | 패턴 매칭               |
| `split()`                                  | 문자열 분리             |
| `replace()`                                | 문자열 대체             |
| `toUpperCase()`, `toLowerCase()`           | 대소문자 변경           |
| `trim()`                                   | 앞뒤 공백 제거          |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        String s = " Hello Java ";
        System.out.println(s.trim().toUpperCase());  // "HELLO JAVA"

        String[] parts = s.trim().split(" ");
        for (String part : parts) {
            System.out.println(part);  // Hello, Java
        }
    }
}
```

------

### 🔷 3. `Math` 클래스

#### 🌟 개요

- 수학 관련 정적 메서드를 제공
- 인스턴스를 만들 수 없음 (`private` 생성자)

#### 🧩 주요 메서드

| 메서드                         | 설명                          |
| ------------------------------ | ----------------------------- |
| `abs()`, `max()`, `min()`      | 기본적인 수치 계산            |
| `pow(x, y)`                    | x의 y 제곱                    |
| `sqrt(x)`                      | 제곱근                        |
| `round()`, `ceil()`, `floor()` | 반올림, 올림, 내림            |
| `random()`                     | 0.0 이상 1.0 미만의 난수 반환 |
| `sin()`, `cos()`, `tan()`      | 삼각 함수                     |
| `log()`, `exp()`               | 로그, 지수 함수               |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        double r = Math.random();      // 0.0 ~ 1.0
        int n = (int)(r * 100);        // 0 ~ 99
        System.out.println(n);

        System.out.println(Math.pow(2, 10)); // 1024.0
        System.out.println(Math.round(3.6)); // 4
    }
}
```

------

### 🔷 4. `System` 클래스

#### 🌟 개요

- **시스템 관련 기능**을 제공하는 유틸리티 클래스
- `System.out`, `System.err`, `System.in` 등 표준 입출력
- `System.gc()`, `System.currentTimeMillis()` 등 제공

#### 🧩 주요 메서드

| 메서드                              | 설명                         |
| ----------------------------------- | ---------------------------- |
| `System.out.println()`              | 표준 출력 스트림             |
| `System.err.println()`              | 에러 출력 스트림             |
| `System.in`                         | 입력 스트림 (Scanner로 연결) |
| `exit(int)`                         | 프로그램 종료                |
| `gc()`                              | GC 요청                      |
| `currentTimeMillis()`, `nanoTime()` | 시간 측정                    |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 1000000; i++) {}  // 단순 연산

        long end = System.currentTimeMillis();
        System.out.println("걸린 시간: " + (end - start) + "ms");

        System.exit(0);  // 명시적 종료
    }
}
```

------

### 🔷 5. `Class` 클래스

#### 🌟 개요

- 자바의 리플렉션 API 핵심 클래스
- 객체 또는 타입의 **메타정보를 다룰 수 있음**
- `getClass()` 혹은 `Class.forName()` 사용

#### 🧩 주요 메서드

| 메서드                                        | 설명              |
| --------------------------------------------- | ----------------- |
| `getName()`, `getSimpleName()`                | 클래스 이름       |
| `getDeclaredFields()`, `getDeclaredMethods()` | 필드/메서드 목록  |
| `newInstance()` (Deprecated)                  | 객체 생성         |
| `getSuperclass()`, `isInterface()`            | 상속 및 타입 체크 |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("java.lang.String");
        System.out.println(clazz.getSimpleName()); // String

        for (var method : clazz.getDeclaredMethods()) {
            System.out.println(method.getName());
        }
    }
}
```

------

### 🧠 심화 포인트 요약

| 클래스   | 주요 특징          | 일반 용도                 |
| -------- | ------------------ | ------------------------- |
| `Object` | 모든 클래스의 조상 | 공통 메서드 재정의        |
| `String` | 불변 객체          | 문자열 처리               |
| `Math`   | 수학 함수 모음     | 수치 연산                 |
| `System` | 시스템 제어        | 입출력, 시간, 종료        |
| `Class`  | 리플렉션           | 메타 정보 획득, 동적 로딩 |

## StringBuilder, StringBuffer

`StringBuilder`와 `StringBuffer`는 Java에서 **문자열을 효율적으로 조작**할 수 있도록 만든 클래스이다. `String`은 불변(immutable) 객체라서 문자열을 수정할 때마다 새로운 인스턴스가 만들어지는 반면, 이 둘은 **가변(mutable) 문자열 클래스**로서, 성능 면에서 훨씬 유리하다.

------

### 🔷 개요 비교: `String` vs `StringBuilder` vs `StringBuffer`

| 구분        | String                   | StringBuilder           | StringBuffer                    |
| ----------- | ------------------------ | ----------------------- | ------------------------------- |
| 불변성      | ✅ 불변 (immutable)       | ❌ 가변 (mutable)        | ❌ 가변 (mutable)                |
| 스레드 안전 | ❌ 안전하지 않음          | ❌ 안전하지 않음         | ✅ 스레드 안전 (synchronized)    |
| 속도        | 느림 (매번 새 객체 생성) | 빠름                    | 느림 (`synchronized` 때문)      |
| 용도        | 변경이 거의 없는 문자열  | 단일 스레드 문자열 조작 | 멀티스레드 환경에서 문자열 조작 |

------

### 🔹 1. `StringBuilder`

#### 🌟 특징

- Java 5부터 추가
- 비동기 환경에서 빠른 문자열 수정 가능
- `append()`, `insert()`, `delete()` 등 다양한 메서드 제공

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");
        sb.append(" World");
        sb.insert(5, ",");
        sb.replace(6, 11, "Java");
        sb.delete(0, 1);

        System.out.println(sb.toString());  // ello,Java
    }
}
```

#### 🧩 주요 메서드

| 메서드                      | 설명              |
| --------------------------- | ----------------- |
| `append(String)`            | 문자열 끝에 추가  |
| `insert(int, String)`       | 특정 위치에 삽입  |
| `delete(int, int)`          | 문자열 삭제       |
| `replace(int, int, String)` | 특정 구간 대체    |
| `reverse()`                 | 문자열 뒤집기     |
| `toString()`                | `String`으로 변환 |

------

### 🔹 2. `StringBuffer`

#### 🌟 특징

- Java 초창기부터 존재
- `StringBuilder`와 거의 동일하지만, 모든 메서드가 `synchronized`로 보호됨
- 멀티스레드 환경에서 데이터 일관성 보장

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("Good");
        sb.append(" Morning");
        sb.insert(4, ",");
        sb.delete(0, 1);

        System.out.println(sb.toString());  // ood, Morning
    }
}
```

------

### 🔧 사용 시기 요약

| 상황                                  | 추천 클래스     |
| ------------------------------------- | --------------- |
| 문자열 변경이 거의 없음               | `String`        |
| 단일 스레드 환경에서 많은 문자열 조작 | `StringBuilder` |
| 멀티스레드 환경에서 문자열 조작 필요  | `StringBuffer`  |

------

### 🧠 성능 테스트 예시

```
public class Test {
    public static void main(String[] args) {
        long start, end;

        // StringBuilder
        StringBuilder sb = new StringBuilder();
        start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            sb.append("a");
        }
        end = System.currentTimeMillis();
        System.out.println("StringBuilder: " + (end - start) + "ms");

        // String
        String s = "";
        start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            s += "a";  // 비효율적
        }
        end = System.currentTimeMillis();
        System.out.println("String: " + (end - start) + "ms");
    }
}
```

------

### 🔍 참고: 용량 증가 방식

- `StringBuilder`/`StringBuffer`는 내부적으로 `char[]` 배열을 사용
- 용량 초과 시, 자동으로 **기하급수적으로 크기 증가** (기본 16 → 34 → 70...)
- 이 과정은 비용이 크기 때문에 초기 용량을 지정하는 것이 좋음:

```
StringBuilder sb = new StringBuilder(10000);  // 예상 용량 지정
```

------

### ✅ 정리

| 항목               | String      | StringBuilder         | StringBuffer   |
| ------------------ | ----------- | --------------------- | -------------- |
| 변경 가능          | ❌           | ✅                     | ✅              |
| 스레드 안전        | ❌           | ❌                     | ✅              |
| 성능 (단일 스레드) | 느림        | 빠름                  | 비교적 느림    |
| 사용 목적          | 정적 문자열 | 빠른 동적 문자열 처리 | 동기화 필요 시 |

## Wrapper 클래스: Integer, Double, Boolean 등

Java의 **Wrapper 클래스**는 기본형(primitive type)을 객체(object)처럼 다루기 위해 만들어진 **기본형 포장 클래스**이다. `int`, `double`, `boolean` 같은 기본 타입은 객체가 아니라서 컬렉션 등에 사용할 수 없다. 그래서 Java는 **기본형을 참조형(클래스)으로 감싸는 Wrapper 클래스**를 제공한다.

------

### 🔷 1. Wrapper 클래스란?

| 기본형    | 래퍼 클래스 |
| --------- | ----------- |
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

#### 🔧 사용 이유

- 컬렉션(`List`, `Set`, `Map`)에 기본형을 넣을 수 없음 → 객체로 감싸야 함
- 제네릭에서 기본형 사용 불가 → `List<int>` ❌, `List<Integer>` ✅
- null 표현 가능 (기본형은 null을 표현 못함)

------

### 🔹 2. 오토박싱(Auto Boxing) & 오토언박싱(Unboxing)

#### ✅ 설명

- 오토박싱: 기본형 → Wrapper 클래스로 자동 변환
- 오토언박싱: Wrapper 객체 → 기본형으로 자동 변환

```
int i = 10;
Integer iObj = i;          // 오토박싱
int j = iObj;              // 오토언박싱
```

------

### 🔹 3. 주요 메서드와 생성 방법

#### ✅ `Integer`, `Double`, `Boolean` 예제

```
public class Main {
    public static void main(String[] args) {
        Integer i = Integer.valueOf("123");      // 문자열 → Integer
        int x = Integer.parseInt("456");         // 문자열 → int

        Double d = Double.valueOf("3.14");
        double y = Double.parseDouble("2.71");

        Boolean b1 = Boolean.valueOf("true");
        boolean b2 = Boolean.parseBoolean("false");

        System.out.println(i + x); // 579
        System.out.println(d + y); // 5.85
        System.out.println(b1 && b2); // false
    }
}
```

------

### 🔹 4. 주요 메서드 정리

#### ✅ `Integer` 클래스

| 메서드                        | 설명                    |
| ----------------------------- | ----------------------- |
| `valueOf(String)`             | 문자열 → `Integer` 객체 |
| `parseInt(String)`            | 문자열 → `int`          |
| `compareTo(Integer)`          | 두 숫자 비교            |
| `equals(Object)`              | 값 비교                 |
| `toString()`                  | 문자열 변환             |
| `intValue()`, `doubleValue()` | 기본형 추출             |

#### ✅ `Boolean` 클래스

| 메서드                 | 설명                   |
| ---------------------- | ---------------------- |
| `parseBoolean(String)` | 문자열 `"true"`면 true |
| `valueOf(String)`      | 문자열을 `Boolean`으로 |
| `booleanValue()`       | 기본형 반환            |
| `toString()`           | `"true"` or `"false"`  |

------

### 🧠 박싱과 캐싱

- `Integer` 등은 **[-128 ~ 127] 범위**의 값을 **미리 캐싱**함.
- 해당 범위 값은 항상 같은 객체 참조를 반환:

```
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true (같은 객체)

Integer c = 1000;
Integer d = 1000;
System.out.println(c == d); // false (다른 객체)
```

> `==` 연산자는 참조 비교임. **값 비교는 `.equals()` 사용**해야 함.

------

### 🔍 null 처리 주의

- 오토언박싱 시 `null` 값을 기본형으로 바꾸려 하면 `NullPointerException` 발생:

```
Integer i = null;
int x = i;  // ⚠️ 예외 발생
```

------

### 🧩 Wrapper 클래스의 활용 예시: 컬렉션

```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        numbers.add(10);  // 오토박싱
        numbers.add(20);
        numbers.add(30);

        for (int n : numbers) {  // 오토언박싱
            System.out.println(n);
        }
    }
}
```

------

### ✅ 정리 요약

| 항목 | 설명                                     |
| ---- | ---------------------------------------- |
| 정의 | 기본형을 객체로 다루기 위한 클래스       |
| 목적 | 컬렉션/제네릭 사용, null 표현, 객체 조작 |
| 특징 | 불변(immutable), 오토박싱/언박싱         |
| 주의 | 캐싱 범위 확인, `null` 언박싱 주의       |

## Runtime, Enum, Throwable, assert

### 🔷 1. `Runtime` 클래스

#### 🌟 개요

- **JVM 런타임 환경과 상호작용**할 수 있게 해주는 클래스
- `Runtime.getRuntime()`으로 인스턴스를 얻은 후, 시스템 자원을 제어 가능
- 프로세스 실행, 메모리 정보, 종료 처리 등에 사용

#### ✅ 주요 메서드

| 메서드                    | 설명                             |
| ------------------------- | -------------------------------- |
| `exec(String)`            | 외부 프로그램 실행               |
| `gc()`                    | 가비지 컬렉터 호출 요청          |
| `freeMemory()`            | 사용 가능한 메모리 양            |
| `totalMemory()`           | JVM에 할당된 총 메모리           |
| `maxMemory()`             | JVM이 사용할 수 있는 최대 메모리 |
| `addShutdownHook(Thread)` | JVM 종료 전에 실행할 작업 등록   |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) throws Exception {
        Runtime rt = Runtime.getRuntime();

        System.out.println("Free Memory: " + rt.freeMemory());
        System.out.println("Total Memory: " + rt.totalMemory());

        // 외부 명령 실행 (윈도우: notepad, 리눅스: gedit 등)
        // Process p = rt.exec("notepad");

        // 종료 훅 추가
        rt.addShutdownHook(new Thread(() -> System.out.println("JVM 종료 직전입니다.")));

        // 가비지 컬렉션 유도
        rt.gc();
    }
}
```

> 외부 프로그램 실행 시, `Process` 객체를 반환하며 I/O 스트림을 통해 결과를 처리할 수도 있음.

------

### 🔷 2. `Enum` 클래스

#### 🌟 개요

- Java 5부터 도입된 **타입 안전한 상수 집합**
- 내부적으로 `java.lang.Enum` 클래스를 **암묵적으로 상속**
- 열거형은 클래스처럼 동작하며, 필드, 생성자, 메서드 포함 가능

#### ✅ 기본 사용

```
enum Direction {
    NORTH, SOUTH, EAST, WEST
}

public class Main {
    public static void main(String[] args) {
        Direction d = Direction.NORTH;
        System.out.println(d);                // NORTH
        System.out.println(d.name());         // NORTH
        System.out.println(d.ordinal());      // 0
    }
}
```

#### ✅ 고급 예시 (필드 + 생성자 + 메서드)

```
enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    EARTH(5.976e+24, 6.37814e6);

    private final double mass;   // in kilograms
    private final double radius; // in meters

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    double surfaceGravity() {
        final double G = 6.67300E-11;
        return G * mass / (radius * radius);
    }
}
```

#### ✅ 주요 메서드

| 메서드            | 설명                        |
| ----------------- | --------------------------- |
| `values()`        | 모든 열거 상수 배열 반환    |
| `valueOf(String)` | 문자열로부터 열거 상수 반환 |
| `ordinal()`       | 정의 순서 (0부터 시작)      |
| `name()`          | 상수 이름 반환              |

------

### 🔷 3. `Throwable` 클래스

#### 🌟 개요

- 자바의 모든 **에러 및 예외의 최상위 클래스**
- 하위 클래스:
  - `Error`: 시스템 오류 (예: `OutOfMemoryError`, `StackOverflowError`)
  - `Exception`: 일반적인 예외 (`IOException`, `SQLException` 등)
    - `RuntimeException`: 실행 시점 예외 (NullPointer 등)

#### ✅ 계층 구조

```
Throwable
├── Error
│   └── OutOfMemoryError, StackOverflowError 등
└── Exception
    ├── IOException, SQLException
    └── RuntimeException
        └── NullPointerException, IndexOutOfBoundsException 등
```

#### ✅ 주요 메서드

| 메서드              | 설명                    |
| ------------------- | ----------------------- |
| `getMessage()`      | 예외 메시지             |
| `printStackTrace()` | 스택 트레이스 출력      |
| `getCause()`        | 예외의 원인 반환        |
| `getStackTrace()`   | 스택 트레이스 배열 반환 |

#### ✅ 예시

```
public class Main {
    public static void main(String[] args) {
        try {
            int x = 5 / 0;
        } catch (ArithmeticException e) {
            System.out.println("예외 발생: " + e.getMessage());
            e.printStackTrace();  // 어디서 발생했는지
        }
    }
}
```

------

### 🔷 4. `assert` 키워드

#### 🌟 개요

- Java 1.4부터 도입
- **디버깅용 런타임 조건 검사 도구**
- 조건이 `false`일 경우 `AssertionError`를 발생시킴
- 기본적으로 **비활성화되어 있음** → `-ea` (enable assertions) 옵션 필요

#### ✅ 사용법

```
int score = -1;
assert score >= 0 : "점수는 음수일 수 없습니다.";
```

#### ✅ 실행 방법

```
java -ea Main
```

#### ✅ 주의사항

- **프로덕션 코드에서는 사용하지 않는 것이 일반적**
- 반드시 예외 처리를 대체하지 않도록 주의

------

### ✅ 요약 표

| 항목        | 설명                         | 주 용도                       |
| ----------- | ---------------------------- | ----------------------------- |
| `Runtime`   | JVM 실행 환경 제어           | 외부 명령 실행, 메모리 확인   |
| `Enum`      | 타입 안정 상수 집합          | 상태값, 분기 처리             |
| `Throwable` | 예외 및 오류의 최상위 클래스 | 예외 처리 및 추적             |
| `assert`    | 디버깅용 조건 검사           | 테스트 또는 개발 시 조건 검증 |

# 9.2 `java.util`

## 컬렉션 프레임워크: List, Set, Map, Queue

Java의 **컬렉션 프레임워크(Collection Framework)** 는 데이터를 효율적으로 저장하고, 탐색하고, 조작할 수 있도록 다양한 **자료구조(자료형)와 알고리즘**을 제공하는 표준 API 집합이다. 이 중에서도 가장 많이 사용되는 핵심 인터페이스는 `List`, `Set`, `Map`, `Queue` 네 가지이고, 각각의 구현체가 있다.

------

### 🔷 전체 구조 개요

```
java.util.Collection (interface)
├── List (순서 O, 중복 허용)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector (Legacy)
├── Set (순서 X, 중복 X)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet (정렬)
└── Queue (선입선출 또는 우선순위)
    ├── LinkedList
    └── PriorityQueue

java.util.Map (interface) - Collection과 별개
├── HashMap
├── LinkedHashMap
└── TreeMap (정렬)
```

------

### 🟦 1. `List` 인터페이스

#### ✅ 특징

- **순서 유지 (index 기반)**
- **중복 허용**
- 동적 배열 혹은 연결 리스트 기반 구현체 존재

#### 🔹 주요 구현체

| 구현체       | 특징                                               |
| ------------ | -------------------------------------------------- |
| `ArrayList`  | 배열 기반, 빠른 인덱스 접근, 삽입/삭제는 느림      |
| `LinkedList` | 연결 리스트 기반, 삽입/삭제 빠름, 인덱스 접근 느림 |
| `Vector`     | `ArrayList`와 유사하지만 동기화됨 (거의 사용 X)    |

#### 🔸 예시

```
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("Java"); // 중복 허용
System.out.println(list.get(0));  // Java
```

------

### 🟩 2. `Set` 인터페이스

#### ✅ 특징

- **중복 허용하지 않음**
- **순서가 없거나, 삽입 순서/정렬 순서 유지**

#### 🔹 주요 구현체

| 구현체          | 특징                                                   |
| --------------- | ------------------------------------------------------ |
| `HashSet`       | 해시 기반, 순서 없음                                   |
| `LinkedHashSet` | 삽입 순서 유지                                         |
| `TreeSet`       | 정렬된 순서 유지 (`Comparable` 또는 `Comparator` 기반) |

#### 🔸 예시

```
Set<String> set = new HashSet<>();
set.add("Apple");
set.add("Banana");
set.add("Apple"); // 무시됨

for (String fruit : set) {
    System.out.println(fruit);
}
```

------

### 🟨 3. `Map` 인터페이스 (Collection과 별도)

#### ✅ 특징

- **Key-Value 쌍으로 데이터 저장**
- **Key는 중복 불가, Value는 중복 가능**

#### 🔹 주요 구현체

| 구현체          | 특징                                          |
| --------------- | --------------------------------------------- |
| `HashMap`       | 해시 기반, 순서 없음                          |
| `LinkedHashMap` | 삽입 순서 유지                                |
| `TreeMap`       | 정렬된 Key 순서 유지                          |
| `Hashtable`     | `HashMap`과 유사하지만 동기화됨 (거의 사용 X) |

#### 🔸 예시

```
Map<String, Integer> map = new HashMap<>();
map.put("Apple", 1000);
map.put("Banana", 1500);
map.put("Apple", 1200);  // 기존 값 덮어쓰기

System.out.println(map.get("Apple")); // 1200
```

------

### 🟪 4. `Queue` 인터페이스

#### ✅ 특징

- **FIFO (선입선출)** 방식 자료구조
- 대기열, 작업 큐, 캐시 등에 사용

#### 🔹 주요 구현체

| 구현체          | 특징                                       |
| --------------- | ------------------------------------------ |
| `LinkedList`    | 일반 큐와 덱(double-ended queue) 구현 가능 |
| `PriorityQueue` | 우선순위 큐 (정렬 기준 필요)               |

#### 🔸 예시

```
Queue<String> queue = new LinkedList<>();
queue.offer("Task1");
queue.offer("Task2");

System.out.println(queue.poll());  // Task1 (삭제)
System.out.println(queue.peek());  // Task2 (유지)
```

------

### 🔧 주요 메서드 정리

| 메서드               | `List` | `Set` | `Map`               | `Queue` |
| -------------------- | ------ | ----- | ------------------- | ------- |
| `add()`              | ✅      | ✅     | ❌ (put 사용)        | ✅       |
| `get(index)`         | ✅      | ❌     | ❌                   | ❌       |
| `contains()`         | ✅      | ✅     | ✅ (Key, Value 따로) | ✅       |
| `remove()`           | ✅      | ✅     | ✅                   | ✅       |
| `put(key, value)`    | ❌      | ❌     | ✅                   | ❌       |
| `offer()` / `poll()` | ❌      | ❌     | ❌                   | ✅       |

------

### 🧠 정리 비교표

| 항목        | List                  | Set              | Map                  | Queue                     |
| ----------- | --------------------- | ---------------- | -------------------- | ------------------------- |
| 순서        | 유지                  | 없음 or 유지     | Key 정렬 or 삽입순서 | 일반적으로 유지           |
| 중복        | 허용                  | ❌                | Key ❌ / Value ✅      | 일반적으로 허용           |
| 주요 구현체 | ArrayList, LinkedList | HashSet, TreeSet | HashMap, TreeMap     | LinkedList, PriorityQueue |
| 사용 예     | 순서 있는 데이터      | 유일한 데이터    | Key-Value 저장       | 작업 처리 순서 제어       |

------

### 🔍 예시: 모든 컬렉션 순회

```
// List
List<String> list = List.of("a", "b", "c");
for (String s : list) System.out.println(s);

// Set
Set<String> set = Set.of("x", "y", "z");
set.forEach(System.out::println);

// Map
Map<String, Integer> map = Map.of("A", 1, "B", 2);
map.forEach((k, v) -> System.out.println(k + " : " + v));
```

------

### ✅ 정리 요약

- `List`: 순서가 있고 중복 가능 → 일반적인 배열 형태
- `Set`: 중복 없이 유일한 데이터 저장
- `Map`: 키로 값을 빠르게 찾는 구조
- `Queue`: 순차적인 작업 처리

## 정렬 및 비교: Comparator, Comparable

Java에서 객체를 정렬하려면 **비교 기준**이 필요하다. 이 비교 기준을 제공하는 방식에는 두 가지가 있다:

1. `Comparable` 인터페이스 – **자연 순서 정의**
2. `Comparator` 인터페이스 – **외부에서 별도 기준 정의**

이 두 개념은 Java 컬렉션에서 정렬을 구현하는 핵심 메커니즘이다.

### 🟦 1. `Comparable<T>` – "자연 순서 정의"

#### 🌟 특징

- 클래스 **자체에 정렬 기준을 정의**
- 정렬 기준이 **고정**
- `compareTo()` 메서드만 구현

#### ✅ 사용 예

```
class Person implements Comparable<Person> {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 나이 기준 오름차순 정렬
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }

    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}
```

```
List<Person> list = new ArrayList<>();
list.add(new Person("Alice", 30));
list.add(new Person("Bob", 25));

Collections.sort(list);  // 내부 compareTo() 기준 사용
System.out.println(list);  // [Bob(25), Alice(30)]
```

------

### 🟩 2. `Comparator<T>` – "외부에서 정렬 기준 제공"

#### 🌟 특징

- 정렬 기준을 **외부에서 동적으로 정의**
- 필요에 따라 다양한 정렬 방법 가능
- `compare()` 메서드 구현

#### ✅ 사용 예

```
class Person {
    String name;
    int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String toString() {
        return name + "(" + age + ")";
    }
}
```

```
List<Person> list = new ArrayList<>();
list.add(new Person("Alice", 30));
list.add(new Person("Bob", 25));

// 이름 기준 정렬 (Comparator 사용)
list.sort(Comparator.comparing(p -> p.name));
System.out.println(list);  // [Alice(30), Bob(25)]

// 나이 기준 내림차순 정렬
list.sort((p1, p2) -> Integer.compare(p2.age, p1.age));
System.out.println(list);  // [Alice(30), Bob(25)]
```

------

### 🔄 `Comparable` vs `Comparator` 비교

| 항목      | Comparable                         | Comparator               |
| --------- | ---------------------------------- | ------------------------ |
| 위치      | 클래스 내부                        | 클래스 외부              |
| 메서드    | `compareTo(T o)`                   | `compare(T o1, T o2)`    |
| 유연성    | 하나의 기준만 가능                 | 여러 기준 구현 가능      |
| 수정 범위 | 원본 클래스 수정 필요              | 외부에서 분리 가능       |
| 대표 예   | `String`, `Integer` 등 기본형 객체 | 다양한 정렬 전략 구현 시 |

------

### 🧠 실전 정렬 예시

#### 📌 객체 여러 기준으로 정렬하기

```
// 이름 기준 오름차순
Comparator<Person> byName = Comparator.comparing(p -> p.name);

// 나이 기준 오름차순
Comparator<Person> byAge = Comparator.comparingInt(p -> p.age);

// 나이 기준 내림차순
Comparator<Person> byAgeDesc = Comparator.comparingInt(p -> p.age).reversed();

// 이름 → 나이 순으로 정렬
Comparator<Person> complex = byName.thenComparing(byAge);
```

```
list.sort(complex);  // 다중 기준 정렬 적용
```

------

### 🧪 문자열, 숫자 기본 정렬

```
List<String> list = Arrays.asList("banana", "apple", "cherry");
Collections.sort(list);  // 알파벳 순 (Comparable)

list.sort(Comparator.reverseOrder());  // 역순
```

```
List<Integer> nums = Arrays.asList(5, 1, 7, 3);
Collections.sort(nums);  // 기본 정렬 (오름차순)

nums.sort(Comparator.naturalOrder());
nums.sort(Comparator.reverseOrder()); // 내림차순
```

------

### 🧩 고급 기능 (Java 8 이후)

| 기능          | 예시                                           |
| ------------- | ---------------------------------------------- |
| 메서드 체이닝 | `Comparator.comparing(...).thenComparing(...)` |
| null 처리     | `Comparator.nullsFirst(...)`, `nullsLast(...)` |
| 역순 정렬     | `.reversed()`                                  |
| 람다식 활용   | `(a, b) -> a.prop - b.prop`                    |

```
list.sort(Comparator.nullsLast(Comparator.comparing(p -> p.name)));
```

------

### ✅ 요약 정리

| 구분   | Comparable          | Comparator         |
| ------ | ------------------- | ------------------ |
| 위치   | 클래스 내부         | 외부에서 별도 정의 |
| 메서드 | `compareTo()`       | `compare()`        |
| 기준   | 고정된 하나         | 다수 가능          |
| 예시   | `String`, `Integer` | 사용자 정의 정렬   |

## 유틸리티 클래스: Arrays, Collections, Optional

이 클래스들은 **컬렉션과 배열을 효과적으로 다루기 위한 핵심 도구**들이다.

### 🟦 1. `Arrays` 클래스

#### 🌟 개요

- `java.util.Arrays`
- **배열을 조작하기 위한 유틸리티 메서드 모음**
- `sort()`, `fill()`, `copyOf()`, `equals()` 등

------

#### ✅ 주요 메서드

| 메서드                     | 설명                         |
| -------------------------- | ---------------------------- |
| `sort(array)`              | 배열 정렬                    |
| `copyOf(array, newLength)` | 배열 복사 (크기 변경 포함)   |
| `fill(array, value)`       | 모든 요소를 동일 값으로 채움 |
| `equals(arr1, arr2)`       | 두 배열 내용 비교            |
| `toString(array)`          | 문자열로 표현                |
| `binarySearch(array, key)` | 이진 탐색 (정렬 전제 조건)   |

------

#### ✅ 예시 코드

```
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] nums = {5, 2, 9, 1};

        Arrays.sort(nums);  // [1, 2, 5, 9]
        System.out.println(Arrays.toString(nums));

        int[] copy = Arrays.copyOf(nums, 6);  // [1, 2, 5, 9, 0, 0]
        System.out.println(Arrays.toString(copy));

        Arrays.fill(copy, 100);  // [100, 100, ...]
        System.out.println(Arrays.toString(copy));
    }
}
```

------

### 🟩 2. `Collections` 클래스

#### 🌟 개요

- `java.util.Collections`
- **컬렉션(List, Set, Map 등)의 조작을 위한 유틸리티 메서드 제공**
- 정렬, 최소/최대, 동기화, 불변 컬렉션 생성 등

------

#### ✅ 주요 메서드

| 메서드                                | 설명                 |
| ------------------------------------- | -------------------- |
| `sort(List)`                          | 정렬                 |
| `reverse(List)`                       | 순서 뒤집기          |
| `shuffle(List)`                       | 무작위 섞기          |
| `min(Collection)` / `max(Collection)` | 최소/최대값          |
| `frequency(Collection, obj)`          | 등장 횟수            |
| `unmodifiableList(List)`              | 읽기 전용 뷰 반환    |
| `synchronizedList(List)`              | 스레드 안전한 리스트 |
| `fill(List, val)`                     | 값 채우기            |

------

#### ✅ 예시 코드

```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>(List.of("Banana", "Apple", "Cherry"));

        Collections.sort(fruits);
        System.out.println(fruits);  // [Apple, Banana, Cherry]

        Collections.reverse(fruits);
        System.out.println(fruits);  // [Cherry, Banana, Apple]

        Collections.shuffle(fruits);
        System.out.println(fruits);  // 무작위 순서

        System.out.println(Collections.frequency(fruits, "Apple"));  // 횟수
    }
}
```

------

### 🟨 3. `Optional<T>` 클래스

#### 🌟 개요

- `java.util.Optional`
- **NullPointerException 방지**를 위한 **값 컨테이너**
- 값이 존재하거나 없을 수 있는 상황에서 명시적 표현 제공

------

#### ✅ 주요 메서드

| 메서드                       | 설명                          |
| ---------------------------- | ----------------------------- |
| `Optional.of(value)`         | null 아닌 값 감쌈             |
| `Optional.ofNullable(value)` | null일 수도 있는 값 감쌈      |
| `isPresent()` / `isEmpty()`  | 값 유무 확인                  |
| `get()`                      | 값 반환 (값 없으면 예외 발생) |
| `orElse(default)`            | 기본값 반환                   |
| `orElseGet(Supplier)`        | 지연 실행 기본값              |
| `orElseThrow()`              | 예외 던지기                   |
| `map(Function)`              | 값이 있을 때 함수 적용        |
| `filter(Predicate)`          | 조건 만족 시 유지             |

------

#### ✅ 예시 코드

```
import java.util.Optional;

public class Main {
    public static void main(String[] args) {
        Optional<String> name = Optional.of("Alice");

        System.out.println(name.isPresent());  // true
        System.out.println(name.get());        // Alice

        Optional<String> empty = Optional.empty();
        System.out.println(empty.orElse("No Name"));  // No Name

        String result = name
            .filter(n -> n.startsWith("A"))
            .map(String::toUpperCase)
            .orElse("DEFAULT");
        System.out.println(result);  // ALICE
    }
}
```

------

### 🧠 Optional 실전 팁

| 상황                            | 추천 방식                    |
| ------------------------------- | ---------------------------- |
| 값이 무조건 존재                | `Optional.of(value)`         |
| 값이 null일 수도 있음           | `Optional.ofNullable(value)` |
| 값이 없을 수 있음 → 기본값 사용 | `orElse(default)`            |
| 값이 없을 수 있음 → 예외 발생   | `orElseThrow()`              |
| 값이 있을 때만 가공             | `map()` / `flatMap()`        |
| 값 조건에 따라 필터링           | `filter()`                   |

------

### ✅ 총정리 요약

| 클래스        | 주용도            | 대표 기능                                |
| ------------- | ----------------- | ---------------------------------------- |
| `Arrays`      | 배열 조작         | 정렬, 복사, 비교, 채우기                 |
| `Collections` | 컬렉션 조작       | 정렬, 섞기, 최소/최대, 동기화            |
| `Optional<T>` | Null-safe 값 처리 | 존재 여부 확인, 기본값 대체, 조건 필터링 |

## Scanner, Properties, UUID, Random 등

### 🟦 1. `Scanner` 클래스

#### 🌟 개요

- **입력 처리용 클래스**
- 키보드 입력, 파일, 문자열 등 다양한 입력 소스를 다룰 수 있음
- `java.util.Scanner`

#### ✅ 주요 생성자

```
new Scanner(System.in);         // 콘솔 입력
new Scanner(new File("data.txt")); // 파일 입력
new Scanner("1,2,3").useDelimiter(","); // 구분자 지정
```

#### ✅ 주요 메서드

| 메서드                         | 설명                |
| ------------------------------ | ------------------- |
| `next()`                       | 다음 토큰 반환      |
| `nextLine()`                   | 한 줄 전체 입력     |
| `nextInt()`, `nextDouble()` 등 | 타입별 입력         |
| `hasNext()`                    | 다음 입력 존재 여부 |
| `useDelimiter(regex)`          | 입력 구분자 변경    |

#### 🔸 예시

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("이름 입력: ");
        String name = sc.nextLine();

        System.out.print("나이 입력: ");
        int age = sc.nextInt();

        System.out.println("안녕하세요 " + name + "(" + age + ")");
    }
}
```

------

### 🟩 2. `Properties` 클래스

#### 🌟 개요

- 설정 파일을 **키-값 쌍으로 관리**하는 용도
- `.properties` 파일은 `key=value` 형식
- `java.util.Properties`는 `Map<Object, Object>`를 상속

#### ✅ 주요 메서드

| 메서드                          | 설명           |
| ------------------------------- | -------------- |
| `load(InputStream)`             | 설정 파일 읽기 |
| `store(OutputStream, comments)` | 설정 파일 쓰기 |
| `getProperty(key)`              | 값 읽기        |
| `setProperty(key, value)`       | 값 설정        |

#### 🔸 예시 (읽기)

```
import java.util.Properties;
import java.io.FileInputStream;

public class Main {
    public static void main(String[] args) throws Exception {
        Properties prop = new Properties();
        prop.load(new FileInputStream("config.properties"));

        String host = prop.getProperty("db.host");
        String user = prop.getProperty("db.user");
        System.out.println("Host: " + host + ", User: " + user);
    }
}
```

#### 🔸 예시 (쓰기)

```
Properties prop = new Properties();
prop.setProperty("db.host", "localhost");
prop.setProperty("db.port", "3306");

prop.store(new FileOutputStream("config.properties"), "DB Config");
```

------

### 🟨 3. `UUID` 클래스

#### 🌟 개요

- **범용 고유 식별자(Universally Unique Identifier)** 생성
- 충돌 가능성이 극히 낮음
- `java.util.UUID`

#### ✅ 주요 메서드

| 메서드                    | 설명               |
| ------------------------- | ------------------ |
| `UUID.randomUUID()`       | 임의 UUID 생성     |
| `UUID.fromString(String)` | 문자열 → UUID 객체 |
| `toString()`              | UUID 문자열 반환   |

#### 🔸 예시

```
import java.util.UUID;

public class Main {
    public static void main(String[] args) {
        UUID id = UUID.randomUUID();
        System.out.println(id.toString());  // 예: f81d4fae-7dec-11d0-a765-00a0c91e6bf6
    }
}
```

> 보통 고유 파일 이름, 세션 토큰, 객체 식별자 등에 사용함.

------

### 🟧 4. `Random` 클래스

#### 🌟 개요

- **의사 난수(Pseudo-random number)** 생성
- `java.util.Random` 은 다양한 타입의 난수를 제공
- `ThreadLocalRandom`, `SecureRandom` 등 대안도 있음

#### ✅ 주요 메서드

| 메서드           | 설명                      |
| ---------------- | ------------------------- |
| `nextInt()`      | 32비트 정수 난수          |
| `nextInt(bound)` | 0 ~ bound-1 범위          |
| `nextDouble()`   | 0.0 ~ 1.0 실수            |
| `nextBoolean()`  | true 또는 false           |
| `setSeed(long)`  | 시드값 설정 (재현성 보장) |

#### 🔸 예시

```
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        Random rand = new Random();

        int a = rand.nextInt();          // 무제한 정수
        int b = rand.nextInt(100);       // 0~99
        double d = rand.nextDouble();    // 0.0~1.0
        boolean f = rand.nextBoolean();  // true or false

        System.out.println(a + ", " + b + ", " + d + ", " + f);
    }
}
```

------

### 🧠 실전 응용 요약

| 클래스       | 사용 예시            | 실무 활용                         |
| ------------ | -------------------- | --------------------------------- |
| `Scanner`    | 콘솔 입력, 파일 입력 | 사용자 입력, 로그 분석            |
| `Properties` | 설정파일 읽기/쓰기   | DB 접속 설정, 환경 구성           |
| `UUID`       | 고유 ID 생성         | 토큰, 식별자, 파일 이름           |
| `Random`     | 난수 생성            | 로또 번호, 무작위 추출, 게임 확률 |

# 9.3 `java.time` (Java 8+ 날짜/시간 API)

## LocalDate, LocalTime, LocalDateTime

이 API는 **java.time 패키지**에 있고, 기존의 `Date`/`Calendar`의 문제점(불변성 부족, 혼란스러운 월 인덱스, 스레드 안전성 등)을 대체하기 위해 만들어졌다.

### 🟦 개요: `java.time` API란?

- Java 8부터 추가된 새로운 날짜/시간 처리 API
- **불변(immutable)** 객체 기반
- `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `Instant` 등 다양한 클래스 제공
- 시간대와 상관없이 **순수한 날짜/시간 표현** 가능

------

### ✅ 1. `LocalDate`

#### 📌 개요

- **날짜만 표현**: 연/월/일 (YYYY-MM-DD)
- 시간, 시간대 정보 없음

#### 🌟 주요 메서드

| 메서드                                       | 설명           |
| -------------------------------------------- | -------------- |
| `now()`                                      | 현재 날짜      |
| `of(y, m, d)`                                | 특정 날짜 생성 |
| `getYear()`, `getMonth()`, `getDayOfMonth()` | 날짜 정보 추출 |
| `plusDays(n)`, `minusWeeks(n)`               | 날짜 연산      |
| `isBefore()`, `isAfter()`, `equals()`        | 날짜 비교      |

#### 🔸 예시

```
import java.time.LocalDate;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();                    // 오늘 날짜
        LocalDate birth = LocalDate.of(1995, 10, 12);         // 특정 날짜

        System.out.println("오늘: " + today);
        System.out.println("내 생일: " + birth);
        System.out.println("내 생일까지 " + today.until(birth).getDays() + "일 남음");

        LocalDate future = today.plusDays(10);
        System.out.println("10일 후: " + future);
    }
}
```

------

### ✅ 2. `LocalTime`

#### 📌 개요

- **시간만 표현**: 시/분/초/나노초 (HH:MM:SS.nnnnnnnnn)
- 날짜, 시간대 없음

#### 🌟 주요 메서드

| 메서드                                    | 설명           |
| ----------------------------------------- | -------------- |
| `now()`                                   | 현재 시간      |
| `of(h, m, s)`                             | 특정 시간 생성 |
| `getHour()`, `getMinute()`, `getSecond()` | 시각 정보 추출 |
| `plusHours(n)`, `minusMinutes(n)`         | 시간 연산      |
| `isBefore()`, `isAfter()`                 | 시간 비교      |

#### 🔸 예시

```
import java.time.LocalTime;

public class Main {
    public static void main(String[] args) {
        LocalTime now = LocalTime.now();
        LocalTime classStart = LocalTime.of(9, 0);

        System.out.println("현재 시간: " + now);
        System.out.println("수업 시작 시간: " + classStart);

        System.out.println("수업 시작 전인가? " + now.isBefore(classStart));
    }
}
```

------

### ✅ 3. `LocalDateTime`

#### 📌 개요

- **날짜 + 시간** (시간대 없음)
- `LocalDate`와 `LocalTime`을 결합한 형태

#### 🌟 주요 메서드

| 메서드                           | 설명                              |
| -------------------------------- | --------------------------------- |
| `now()`                          | 현재 날짜+시간                    |
| `of(date, time)`                 | 날짜와 시간 조합                  |
| `toLocalDate()`, `toLocalTime()` | 분리 가능                         |
| `plusDays(n)`, `minusHours(n)`   | 날짜 및 시간 연산                 |
| `format(formatter)`              | 포맷 출력 (→ `DateTimeFormatter`) |

#### 🔸 예시

```
import java.time.LocalDateTime;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime meeting = LocalDateTime.of(2025, 6, 1, 14, 30);

        System.out.println("현재 시각: " + now);
        System.out.println("회의 시각: " + meeting);
        System.out.println("지났는가? " + now.isAfter(meeting));

        // 날짜, 시간 각각 추출
        System.out.println("날짜만: " + meeting.toLocalDate());
        System.out.println("시간만: " + meeting.toLocalTime());
    }
}
```

------

### 🧠 비교 정리표

| 클래스          | 포함 정보       | 사용 예              |
| --------------- | --------------- | -------------------- |
| `LocalDate`     | 년/월/일        | 생일, 기념일, 마감일 |
| `LocalTime`     | 시/분/초/나노초 | 알람, 일정 시작 시간 |
| `LocalDateTime` | 날짜 + 시간     | 회의 시각, 예약 시간 |

------

### 🧩 보너스: 날짜 계산 메서드들

```
LocalDate date = LocalDate.of(2024, 1, 1);
date = date.plusDays(10);        // 10일 후
date = date.minusWeeks(2);       // 2주 전
date = date.withDayOfMonth(15);  // 날짜를 15일로 설정
```

------

### 🧩 날짜 비교 메서드들

```
if (date1.isAfter(date2)) { ... }
if (date1.isBefore(date2)) { ... }
if (date1.equals(date2)) { ... }
```

------

### ✅ 요약 정리

| 클래스          | 특징        | 포함 정보              | 시간대 |
| --------------- | ----------- | ---------------------- | ------ |
| `LocalDate`     | 날짜만      | 연, 월, 일             | ❌      |
| `LocalTime`     | 시간만      | 시, 분, 초             | ❌      |
| `LocalDateTime` | 날짜 + 시간 | 연, 월, 일, 시, 분, 초 | ❌      |

> 💡 시간대 정보가 필요한 경우 `ZonedDateTime`, `OffsetDateTime` 사용

## ZonedDateTime, Instant

Java 8의 `java.time` 패키지에서 시간대와 UTC 타임스탬프를 다루기 위한 **핵심 클래스**이다.
 ✅ `ZonedDateTime`
 ✅ `Instant`

이 둘은 전 세계적인 시간 개념(표준시, 시간대, 타임스탬프)을 정밀하게 다루기 위해 만들어졌고, `LocalDateTime`과는 다르게 **시간대(time zone)** 및 **오프셋(offset)** 을 명시적으로 포함하고 있다.

### 🟦 1. `ZonedDateTime`

#### 🌟 개요

- 날짜와 시간 + **시간대(TimeZone)** 를 포함
- 예: `2025-05-29T20:45:00+09:00[Asia/Seoul]`
- **표현력 가장 풍부한 날짜/시간 클래스**

------

#### ✅ 주요 메서드

| 메서드                      | 설명                           |
| --------------------------- | ------------------------------ |
| `now()`                     | 현재 시간대 기준 ZonedDateTime |
| `of(...)`                   | 날짜/시간/Zone을 조합          |
| `withZoneSameInstant(zone)` | 같은 순간을 다른 시간대로 변환 |
| `withZoneSameLocal(zone)`   | 같은 지역 시간으로 zone만 변경 |
| `toLocalDateTime()`         | 시간대 제거                    |
| `getZone()`, `getOffset()`  | 시간대, 오프셋 정보 추출       |

------

#### ✅ 예시 코드

```
import java.time.*;
import java.time.format.DateTimeFormatter;

public class Main {
    public static void main(String[] args) {
        ZonedDateTime seoulTime = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
        ZonedDateTime utcTime = ZonedDateTime.now(ZoneOffset.UTC);

        System.out.println("서울 시간: " + seoulTime);
        System.out.println("UTC 시간: " + utcTime);

        // 동일 시각을 다른 시간대로 변환
        ZonedDateTime nyTime = seoulTime.withZoneSameInstant(ZoneId.of("America/New_York"));
        System.out.println("뉴욕 시간 (같은 순간): " + nyTime);
    }
}
```

------

#### ✅ 시간대 리스트 조회

```
ZoneId.getAvailableZoneIds().forEach(System.out::println);  // 가능한 시간대 ID 출력
```

------

### 🟨 2. `Instant`

#### 🌟 개요

- **기준 시점(UTC 1970-01-01 00:00:00)** 으로부터 경과한 **초/나노초**를 표현하는 클래스
- UTC 타임스탬프에 대응 (epoch 기반)
- **시간대 없음**, 순수한 "순간"만을 표현
- DB 저장이나 API timestamp 전달에 최적화

------

#### ✅ 주요 메서드

| 메서드                                   | 설명                         |
| ---------------------------------------- | ---------------------------- |
| `now()`                                  | 현재 시각(UTC 기준)          |
| `ofEpochSecond(s)`                       | 에포크 초로부터 Instant 생성 |
| `toEpochMilli()`                         | 밀리초 반환 (long)           |
| `plusSeconds()`, `minusNanos()`          | 시점 계산                    |
| `atZone(ZoneId)`                         | ZonedDateTime으로 변환       |
| `compareTo()`, `isBefore()`, `isAfter()` | 비교 연산                    |

------

#### ✅ 예시 코드

```
import java.time.*;

public class Main {
    public static void main(String[] args) {
        Instant now = Instant.now();  // UTC 기준 시점
        System.out.println("현재 Instant: " + now);

        long epochMillis = now.toEpochMilli();  // 1970 이후 밀리초
        System.out.println("Epoch millis: " + epochMillis);

        ZonedDateTime zoned = now.atZone(ZoneId.of("Asia/Seoul"));
        System.out.println("Instant → ZonedDateTime: " + zoned);
    }
}
```

------

### 🔄 `ZonedDateTime` vs `Instant` 비교

| 항목        | `ZonedDateTime`                 | `Instant`                                 |
| ----------- | ------------------------------- | ----------------------------------------- |
| 포함 정보   | 날짜, 시간, 시간대, 오프셋      | UTC 기준 타임스탬프                       |
| 시간대 포함 | ✅ 포함 (`ZoneId`, `ZoneOffset`) | ❌ 없음                                    |
| 사용 목적   | 사용자 시각 표현, 시간대 변환   | 시스템/네트워크 시간 기록                 |
| 변환 대상   | `LocalDateTime`, `Instant`      | `ZonedDateTime`, `LocalDateTime + ZoneId` |

------

### 🧠 예제: `LocalDateTime` ↔ `ZonedDateTime` ↔ `Instant`

```
// LocalDateTime → ZonedDateTime → Instant
LocalDateTime ldt = LocalDateTime.of(2025, 1, 1, 12, 0);
ZonedDateTime zoned = ldt.atZone(ZoneId.of("Asia/Seoul"));
Instant instant = zoned.toInstant();

System.out.println("UTC Timestamp: " + instant);

// Instant → ZonedDateTime → LocalDateTime
ZonedDateTime newZoned = instant.atZone(ZoneId.of("Europe/London"));
LocalDateTime ldtInLondon = newZoned.toLocalDateTime();
```

------

### ✅ 정리 요약

| 클래스          | 목적                     | 예                         |
| --------------- | ------------------------ | -------------------------- |
| `ZonedDateTime` | 날짜 + 시간 + 시간대     | 예약 시스템, 다국가 서비스 |
| `Instant`       | UTC 시점 (밀리초/나노초) | 타임스탬프, 로그 기록      |

## Duration, Period

✅ `Duration`
✅ `Period`

이 두 클래스는 각각 **시간 단위 간격**, **날짜 단위 간격**을 나타내는 데 사용된다.

### 🟦 1. `Duration`

#### 🌟 개요

- **시/분/초/나노초** 단위로 시간 차이를 나타냄
- `Instant`, `LocalTime`, `LocalDateTime` 등의 시간 API와 함께 사용
- 단위: 초(Seconds), 나노초(Nanos)

------

#### ✅ 주요 메서드

| 메서드                                   | 설명                   |
| ---------------------------------------- | ---------------------- |
| `Duration.between(start, end)`           | 두 시점 간의 간격 생성 |
| `toHours()`, `toMinutes()`, `toMillis()` | 시간 단위 변환         |
| `plusXxx()`, `minusXxx()`                | 간격 연산              |
| `isZero()`, `isNegative()`               | 상태 체크              |

------

#### 🔸 예시: `Duration` 사용

```
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalTime start = LocalTime.of(9, 0);
        LocalTime end = LocalTime.of(14, 30);

        Duration duration = Duration.between(start, end);
        System.out.println("총 시간(분): " + duration.toMinutes()); // 330분
        System.out.println("총 시간(초): " + duration.getSeconds()); // 19800초
    }
}
```

#### 🔸 예시: `Instant` 간격

```
Instant before = Instant.now();
// 작업 수행...
Instant after = Instant.now();

Duration gap = Duration.between(before, after);
System.out.println("작업 소요: " + gap.toMillis() + "ms");
```

------

### 🟨 2. `Period`

#### 🌟 개요

- **년/월/일** 단위로 날짜 간격을 나타냄
- `LocalDate` 전용
- 단위: 연(Years), 월(Months), 일(Days)

------

#### ✅ 주요 메서드

| 메서드                                   | 설명              |
| ---------------------------------------- | ----------------- |
| `Period.between(start, end)`             | 두 날짜 간격 계산 |
| `getYears()`, `getMonths()`, `getDays()` | 기간 정보 추출    |
| `plusXxx()`, `minusXxx()`                | 기간 연산         |
| `isZero()`, `isNegative()`               | 상태 체크         |

------

#### 🔸 예시: 생일 계산

```
import java.time.*;

public class Main {
    public static void main(String[] args) {
        LocalDate birth = LocalDate.of(1995, 5, 29);
        LocalDate today = LocalDate.now();

        Period age = Period.between(birth, today);

        System.out.println("나이: " + age.getYears() + "세 " +
                           age.getMonths() + "개월 " +
                           age.getDays() + "일");
    }
}
```

------

### 🔁 비교: `Duration` vs `Period`

| 항목      | `Duration`                              | `Period`               |
| --------- | --------------------------------------- | ---------------------- |
| 단위      | 시간 기반 (초, 나노초)                  | 날짜 기반 (년, 월, 일) |
| 대상      | `Instant`, `LocalTime`, `LocalDateTime` | `LocalDate`            |
| 정확도    | 밀리초/나노초까지                       | 년/월/일까지만         |
| 대표 사용 | 타이머, 작업 수행 시간                  | 생일, 만기일 계산      |

------

### 🧠 기타 생성 방법

```
Duration threeHours = Duration.ofHours(3);
Duration tenMinutes = Duration.ofMinutes(10);

Period oneWeek = Period.ofWeeks(1);
Period threeMonths = Period.of(0, 3, 0);  // 3개월
```

------

### ✅ 정리 요약

| 클래스     | 사용 대상                          | 표현 단위  | 사용 예                       |
| ---------- | ---------------------------------- | ---------- | ----------------------------- |
| `Duration` | 시간/시각 (`Instant`, `LocalTime`) | 초, 나노초 | 타이머, 실행 시간             |
| `Period`   | 날짜 (`LocalDate`)                 | 년, 월, 일 | 나이, 대출 만기, 이벤트 D-Day |

## DateTimeFormatter, TemporalAdjusters

✅ `DateTimeFormatter`: 날짜/시간의 **문자열 포맷과 파싱**
✅ `TemporalAdjusters`: 날짜의 **정교한 조정(보정) 연산**

### 🟦 1. `DateTimeFormatter`

#### 🌟 개요

- `java.time.format.DateTimeFormatter`
- 날짜/시간을 **문자열로 출력하거나**, 문자열을 **날짜/시간 객체로 파싱**
- `SimpleDateFormat`보다 안전하고 직관적임
- 스레드 안전(thread-safe)

------

#### ✅ 사용 방법

| 메서드                                      | 설명                  |
| ------------------------------------------- | --------------------- |
| `DateTimeFormatter.ofPattern("yyyy-MM-dd")` | 커스텀 포맷 생성      |
| `format(TemporalAccessor)`                  | 날짜/시간 → 문자열    |
| `parse(CharSequence)`                       | 문자열 → 날짜/시간    |
| `DateTimeFormatter.ISO_LOCAL_DATE`          | 사전 정의된 포맷 사용 |

------

#### 📌 패턴 문자열 예시

| 패턴                  | 의미        | 예시                  |
| --------------------- | ----------- | --------------------- |
| `yyyy`                | 연도        | 2025                  |
| `MM`                  | 월 (2자리)  | 05                    |
| `dd`                  | 일          | 29                    |
| `HH`                  | 시 (24시간) | 13                    |
| `mm`                  | 분          | 07                    |
| `ss`                  | 초          | 45                    |
| `a`                   | 오전/오후   | AM, PM                |
| `E`                   | 요일        | Tue                   |
| `yyyy-MM-dd HH:mm:ss` | 전체        | `2025-05-29 14:30:00` |

------

#### 🔸 예시: 날짜를 포맷하기

```
import java.time.*;
import java.time.format.*;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH:mm:ss");

        String formatted = now.format(fmt);
        System.out.println("포맷된 시간: " + formatted);  // 2025년 05월 29일 14:40:23
    }
}
```

------

#### 🔸 예시: 문자열 파싱하기

```
String input = "2025-12-01 10:30";
DateTimeFormatter parser = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
LocalDateTime parsed = LocalDateTime.parse(input, parser);
System.out.println("파싱된 객체: " + parsed);
```

------

### 🟨 2. `TemporalAdjusters`

#### 🌟 개요

- `java.time.temporal.TemporalAdjusters`
- `LocalDate`, `LocalDateTime` 등 날짜 객체에 대해 **보정(조정)** 연산을 수행
- "이번 달의 첫 날", "다음 금요일", "마지막 일요일" 같은 **자연어적 날짜 계산** 가능

------

#### ✅ 주요 메서드

| 메서드                      | 설명                                 |
| --------------------------- | ------------------------------------ |
| `firstDayOfMonth()`         | 해당 달의 첫째 날                    |
| `lastDayOfMonth()`          | 해당 달의 마지막 날                  |
| `firstInMonth(DayOfWeek)`   | 해당 요일의 첫 번째                  |
| `lastInMonth(DayOfWeek)`    | 해당 요일의 마지막                   |
| `next(DayOfWeek)`           | 다음 해당 요일                       |
| `previous(DayOfWeek)`       | 이전 해당 요일                       |
| `nextOrSame(DayOfWeek)`     | 오늘이 그 요일이면 유지, 아니면 다음 |
| `previousOrSame(DayOfWeek)` | 오늘이 그 요일이면 유지, 아니면 이전 |

------

#### 🔸 예시: 월급날, 금요일 찾기

```
import java.time.*;
import java.time.temporal.*;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();

        LocalDate firstDay = today.with(TemporalAdjusters.firstDayOfMonth());
        LocalDate lastDay = today.with(TemporalAdjusters.lastDayOfMonth());

        LocalDate nextFriday = today.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));
        LocalDate lastSunday = today.with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));

        System.out.println("이번 달 첫날: " + firstDay);
        System.out.println("이번 달 마지막날: " + lastDay);
        System.out.println("다음 금요일: " + nextFriday);
        System.out.println("이번 달 마지막 일요일: " + lastSunday);
    }
}
```

------

### 🧠 `with()` 메서드와 함께 사용

```
LocalDate payday = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
```

이렇게 `.with()`에 adjuster를 넘기면 해당 날짜 객체를 보정한 새로운 객체가 반환돼.

------

### ✅ 요약 비교

| 항목        | `DateTimeFormatter`                           | `TemporalAdjusters`               |
| ----------- | --------------------------------------------- | --------------------------------- |
| 목적        | 포맷 및 파싱                                  | 날짜 보정 (자연어 계산)           |
| 주요 대상   | `LocalDate`, `LocalDateTime`, `ZonedDateTime` | `LocalDate`, `LocalDateTime`      |
| 주요 용도   | 문자열 변환                                   | 첫날, 마지막날, 특정 요일 등 계산 |
| 핵심 메서드 | `format()`, `parse()`                         | `with(...)` + 정적 메서드         |

# 9.4 난수 생성

## Random, SecureRandom, ThreadLocalRandom

✅ `Random`
✅ `SecureRandom`
✅ `ThreadLocalRandom`

이 세 클래스는 모두 난수 생성 기능을 제공하지만, 목적과 내부 구현 방식, 성능이 매우 다르다.

### 🟦 1. `Random`

#### 🌟 개요

- `java.util.Random`
- 가장 일반적인 **의사 난수 생성기 (Pseudo-random generator)**
- `Linear Congruential Generator` 알고리즘 사용
- 단일 스레드에서는 적절하지만, **멀티스레드 환경에서는 경쟁 발생**

------

#### ✅ 주요 메서드

| 메서드           | 설명                         |
| ---------------- | ---------------------------- |
| `nextInt()`      | 임의의 int 생성              |
| `nextInt(bound)` | 0 이상 bound 미만의 int      |
| `nextDouble()`   | 0.0 ~ 1.0 실수               |
| `nextBoolean()`  | true 또는 false              |
| `setSeed(long)`  | 시드값 설정 (결과 재현 가능) |

------

#### 🔸 예시

```
import java.util.Random;

Random rand = new Random();
int num = rand.nextInt(100);     // 0~99
double d = rand.nextDouble();    // 0.0 ~ 1.0
boolean b = rand.nextBoolean();  // true or false
```

------

### 🟨 2. `SecureRandom`

#### 🌟 개요

- `java.security.SecureRandom`
- **암호학적으로 안전한 난수 생성기**
- 내부적으로 운영체제의 난수 소스 (ex. `/dev/urandom`) 를 사용
- **보안 토큰, 암호 키, UUID** 생성에 사용됨
- **느리지만 강력함**

------

#### ✅ 주요 메서드

| 메서드                           | 설명             |
| -------------------------------- | ---------------- |
| `nextInt()`, `nextBytes(byte[])` | 난수 생성        |
| `setSeed(byte[])`                | 고유한 시드 설정 |
| `generateSeed(int)`              | 시드 생성        |

------

#### 🔸 예시

```
import java.security.SecureRandom;

SecureRandom secureRand = new SecureRandom();
int num = secureRand.nextInt(1000);  // 0~999
byte[] bytes = new byte[16];
secureRand.nextBytes(bytes);         // 랜덤 바이트 배열 생성
```

------

### 🟩 3. `ThreadLocalRandom`

#### 🌟 개요

- `java.util.concurrent.ThreadLocalRandom`
- Java 7부터 도입
- **멀티스레드 환경에 최적화된 난수 생성기**
- 각 쓰레드마다 독립적인 시드를 가짐 → 경쟁 없음 → **가장 빠름**
- **직접 생성자 호출 불가**, `ThreadLocalRandom.current()`로 사용

------

#### ✅ 주요 메서드

| 메서드                      | 설명                    |
| --------------------------- | ----------------------- |
| `current().nextInt()`       | 난수 생성 (정적 메서드) |
| `nextInt(origin, bound)`    | 특정 범위 난수          |
| `nextDouble(origin, bound)` | 실수 범위 난수          |

------

#### 🔸 예시

```
import java.util.concurrent.ThreadLocalRandom;

int n = ThreadLocalRandom.current().nextInt(10, 20);  // 10 이상 20 미만
double d = ThreadLocalRandom.current().nextDouble(0.0, 5.0);
```

------

### 🔁 비교 요약표

| 항목          | `Random`      | `SecureRandom`      | `ThreadLocalRandom`            |
| ------------- | ------------- | ------------------- | ------------------------------ |
| 위치          | `java.util`   | `java.security`     | `java.util.concurrent`         |
| 성능          | 중간          | 느림                | 가장 빠름                      |
| 스레드 안전성 | ❌ (공유 상태) | ✅ (자체 안전)       | ✅ (Thread-local)               |
| 보안성        | 낮음          | 매우 높음           | 낮음                           |
| 시드 제어     | 가능          | 가능                | 불가 (자동 관리)               |
| 대표 용도     | 일반 난수     | 보안 키, 토큰, UUID | 멀티스레드 난수, 병렬 알고리즘 |

------

### 🧪 실전 적용 예시

#### 📌 보안용 토큰

```
SecureRandom sr = new SecureRandom();
byte[] token = new byte[32];
sr.nextBytes(token);
// → Base64 또는 Hex로 인코딩해 사용
```

#### 📌 멀티스레드 로또 번호

```
IntStream.generate(() -> ThreadLocalRandom.current().nextInt(1, 46))
         .distinct()
         .limit(6)
         .forEach(System.out::println);
```

------

### ✅ 정리 요약

| 쓰임새                   | 추천 클래스         |
| ------------------------ | ------------------- |
| 단순 테스트, 단일 스레드 | `Random`            |
| 보안, 암호학, 세션 토큰  | `SecureRandom`      |
| 병렬 처리, 고속 성능     | `ThreadLocalRandom` |

## UUID (고유 식별자 생성)

✅ `UUID (java.util.UUID)`

이 클래스는 데이터베이스 키, 파일 이름, 세션 토큰, 사용자 ID 등 **충돌 없는 고유한 값이 필요한 모든 상황**에서 사용된다.

### 🟦 1. UUID란?

#### 🌟 정의

- **Universally Unique Identifier** (범용 고유 식별자)
- **128비트 길이**의 숫자를 36자 문자열로 표현
- 형식: `"xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx"`

예:

```
f81d4fae-7dec-11d0-a765-00a0c91e6bf6
```

------

### 🧩 UUID 형식 설명

| 구성         | 길이   | 설명                    |
| ------------ | ------ | ----------------------- |
| 8자리        | 32비트 | 시간/랜덤 정보          |
| 4자리        | 16비트 | 시간/랜덤 정보          |
| 4자리 (Mxxx) | 16비트 | UUID 버전 (M)           |
| 4자리 (Nxxx) | 16비트 | Variant 정보            |
| 12자리       | 48비트 | 노드 정보 (MAC or 난수) |

------

### 🟨 2. UUID 버전 종류

| 버전 | 설명                         | Java 지원 여부       |
| ---- | ---------------------------- | -------------------- |
| 1    | 시간 + MAC 주소 기반         | ❌ (Java 기본 미지원) |
| 3    | MD5 해시 기반                | ❌                    |
| 4    | **랜덤 기반 (SecureRandom)** | ✅ 기본 지원          |
| 5    | SHA-1 해시 기반              | ❌                    |

> ✅ Java의 `UUID.randomUUID()`는 **버전 4 (랜덤 기반)** 을 생성해.

------

### 🟩 3. UUID 생성 방법

#### ✅ 랜덤 UUID (버전 4)

```
import java.util.UUID;

UUID id = UUID.randomUUID();
System.out.println(id.toString());
```

예시 출력:

```
3e1d8fc1-b6dc-48e1-b0b4-c8c14b9d7e58
```

------

#### ✅ 문자열 → UUID 객체

```
UUID fromStr = UUID.fromString("3e1d8fc1-b6dc-48e1-b0b4-c8c14b9d7e58");
System.out.println(fromStr.version());  // 4
System.out.println(fromStr.variant());  // 2 (RFC 4122)
```

------

### 🛠 주요 메서드

| 메서드                      | 설명                   |
| --------------------------- | ---------------------- |
| `randomUUID()`              | 난수 기반 UUID 생성    |
| `fromString(String)`        | 문자열로부터 UUID 생성 |
| `toString()`                | UUID를 문자열로 반환   |
| `version()`                 | UUID 버전 (ex. 4)      |
| `variant()`                 | UUID variant 정보      |
| `getMostSignificantBits()`  | 상위 64비트            |
| `getLeastSignificantBits()` | 하위 64비트            |

------

### 🧪 예시: 고유 ID 리스트 만들기

```
List<String> ids = new ArrayList<>();
for (int i = 0; i < 5; i++) {
    ids.add(UUID.randomUUID().toString());
}
ids.forEach(System.out::println);
```

------

### 🔒 SecureRandom과 함께 사용하기

Java의 `UUID.randomUUID()`는 내부적으로 `SecureRandom`을 사용해서 **충돌 가능성**이 극히 낮아.
 하지만 **직접 제어된 `SecureRandom`** 으로 생성하고 싶다면 다음과 같이 할 수 있어:

```
import java.util.UUID;
import java.security.SecureRandom;

SecureRandom sr = new SecureRandom();
byte[] bytes = new byte[16];
sr.nextBytes(bytes);

long msb = 0;
long lsb = 0;
for (int i = 0; i < 8; i++) msb = (msb << 8) | (bytes[i] & 0xff);
for (int i = 8; i < 16; i++) lsb = (lsb << 8) | (bytes[i] & 0xff);

// 버전 4 마스크 적용
msb &= 0xffffffffffff0fffL;
msb |= 0x0000000000004000L;
lsb &= 0x3fffffffffffffffL;
lsb |= 0x8000000000000000L;

UUID secureUUID = new UUID(msb, lsb);
System.out.println(secureUUID);
```

------

### 🧠 실전 활용 예시

| 활용 사례   | 설명                              |
| ----------- | --------------------------------- |
| 파일 이름   | `report-<UUID>.pdf`               |
| RESTful ID  | `/api/users/3e1d8fc1-...`         |
| 세션/토큰   | 쿠키 값, 인증 토큰 등             |
| 분산 시스템 | 전역적으로 충돌 없는 ID 생성 가능 |

------

### ⚠️ 주의사항

- UUID는 **자체적으로 정렬되지 않음**
   → DB 인덱싱 시 **비효율적**일 수 있음 (→ ULID, KSUID 등 고려)
- `UUID.randomUUID()`는 보안적으로 충분히 안전하지만, **진짜 암호 키**로 쓰는 건 권장되지 않음
- UUID 문자열은 **36자** (`32자리 + 4개의 '-'`) → URL 파라미터로 사용 시 인코딩 필요

------

### ✅ 정리 요약

| 항목           | UUID                                          |
| -------------- | --------------------------------------------- |
| 정의           | 전역 고유 식별자 (128비트)                    |
| Java 기본 지원 | ✅ 버전 4 (랜덤 기반)                          |
| 문자열 형식    | `xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx`        |
| 충돌 가능성    | 이론적으로 매우 낮음                          |
| 실무 활용      | 사용자 ID, 파일 이름, API 식별자, 로그 트래킹 |

# 9.5 래퍼 클래스 및 변환

## Boxing/Unboxing

✅ **Boxing** (박싱)
✅ **Unboxing** (언박싱)

Java의 기본형(primitive type)과 참조형(wrapper class) 사이의 자동 변환 개념이다.

이 개념은 Java의 제네릭, 컬렉션, 연산에서 자주 사용되며 **성능과 오류 가능성**에도 영향을 주는 중요한 주제이다.

### 🟦 1. Boxing / Unboxing이란?

| 개념         | 설명                          | 예시            |
| ------------ | ----------------------------- | --------------- |
| **Boxing**   | 기본형 → 참조형으로 자동 변환 | `int → Integer` |
| **Unboxing** | 참조형 → 기본형으로 자동 변환 | `Integer → int` |

✅ **Java 5**부터 **자동 변환(오토박싱/언박싱)** 지원됨.

------

### 🔧 주요 Wrapper 클래스 대응표

| 기본형    | Wrapper 클래스 |
| --------- | -------------- |
| `byte`    | `Byte`         |
| `short`   | `Short`        |
| `int`     | `Integer`      |
| `long`    | `Long`         |
| `float`   | `Float`        |
| `double`  | `Double`       |
| `char`    | `Character`    |
| `boolean` | `Boolean`      |

------

### 🟨 2. 오토박싱 (Auto-boxing)

#### 🔸 예시

```
int a = 10;
Integer boxed = a;  // int → Integer (자동 박싱)

List<Integer> list = new ArrayList<>();
list.add(42);       // 42 → Integer.valueOf(42)
```

→ 내부적으로 다음과 같이 변환됨:

```
Integer boxed = Integer.valueOf(a);
```

------

### 🟩 3. 오토언박싱 (Auto-unboxing)

#### 🔸 예시

```
Integer boxed = Integer.valueOf(123);
int b = boxed;  // Integer → int (자동 언박싱)
```

→ 내부적으로 다음과 같이 변환됨:

```
int b = boxed.intValue();
```

------

### ❗ 주의사항 1: null 언박싱 → `NullPointerException`

```
Integer num = null;
int result = num;  // ❌ NullPointerException 발생!
```

> null을 언박싱하려고 하면 예외 발생 → 반드시 null 체크 필요

------

### ❗ 주의사항 2: `==` vs `equals()` 비교

```
Integer a = 100;
Integer b = 100;
System.out.println(a == b);      // ✅ true (캐시 범위: -128 ~ 127)

Integer x = 1000;
Integer y = 1000;
System.out.println(x == y);      // ❌ false (다른 객체)

System.out.println(x.equals(y)); // ✅ true (값 비교)
```

> `==`는 **참조 비교**, `.equals()`는 **값 비교**

------

### 🧠 내부 캐시: `Integer.valueOf()`

- `-128 ~ 127` 범위는 **JVM 내부 캐시**
- 이 범위의 Integer는 **같은 객체 참조 반환**

```
Integer a = Integer.valueOf(127);
Integer b = Integer.valueOf(127);
System.out.println(a == b);  // true

Integer c = Integer.valueOf(128);
Integer d = Integer.valueOf(128);
System.out.println(c == d);  // false
```

------

### 🧪 실전 활용 예시

#### 📌 제네릭/컬렉션

```
List<Integer> nums = List.of(1, 2, 3);  // 오토박싱
int sum = 0;
for (int n : nums) {  // 오토언박싱
    sum += n;
}
```

------

#### 📌 연산 시 자동 언박싱

```
Integer a = 10;
Integer b = 20;
int result = a + b;  // a.intValue() + b.intValue()
```

------

### ✅ 요약 정리

| 항목 | Boxing                    | Unboxing               |
| ---- | ------------------------- | ---------------------- |
| 정의 | 기본형 → 객체형           | 객체형 → 기본형        |
| 방식 | `int → Integer.valueOf()` | `Integer → intValue()` |
| 특징 | 자동 처리 (Java 5+)       | 성능 약간 저하 가능    |
| 주의 | `null` 언박싱 시 NPE 발생 | `==`은 참조 비교       |

## Integer, Double 등의 parse, valueOf, toString

Java에서 기본형과 문자열 간 변환에 자주 사용되는 메서드들인
 ✅ `parseXXX()`
 ✅ `valueOf()`
 ✅ `toString()`
 에 대해 **`Integer`, `Double`, `Boolean`** 등의 래퍼 클래스 중심으로 정리한다.

이 메서드들은 **문자열을 숫자(또는 불리언)으로 바꾸거나, 숫자를 문자열로 바꾸는 핵심 도구**이다. 실무에서 **입력 처리, 설정값 파싱, 파일 입출력, JSON 처리** 등에 매우 자주 사용된다.

### 🟦 1. `parseXXX(String)`

> 문자열 → **기본형(primitive)** 으로 변환

#### 📌 특징

- 리턴 타입이 `int`, `double`, `boolean` 등 **기본형**
- 내부적으로 **문자열을 해석(parse)**

#### ✅ 예시

```
int n = Integer.parseInt("123");         // → 123
double d = Double.parseDouble("3.14");   // → 3.14
boolean b = Boolean.parseBoolean("true");// → true
```

------

### 🟩 2. `valueOf(String)`

> 문자열 → **래퍼 객체(wrapper)** 로 변환

#### 📌 특징

- 리턴 타입이 `Integer`, `Double`, `Boolean` 등 **객체**
- 내부적으로 캐싱 활용 (`Integer.valueOf()`는 -128 ~ 127까지 캐싱)

#### ✅ 예시

```
Integer n = Integer.valueOf("123");      // → Integer 객체
Double d = Double.valueOf("3.14");       // → Double 객체
Boolean b = Boolean.valueOf("false");    // → Boolean 객체
```

> 💡 내부적으로 `parseXXX()` 호출 + Boxing

------

### 🟨 3. `toString()`

> 숫자 → 문자열 변환

#### 📌 특징

- 래퍼 클래스의 인스턴스 또는 정적 메서드로 제공
- 문자열 출력, 로그 기록 등에 사용

#### ✅ 예시

```
Integer n = 100;
String s1 = n.toString();               // 인스턴스 메서드
String s2 = Integer.toString(200);      // 정적 메서드
```

------

### 🔁 전체 변환 흐름 비교

| 방향               | 메서드                                             | 반환      |
| ------------------ | -------------------------------------------------- | --------- |
| 문자열 → 기본형    | `parseXXX("123")`                                  | `int`     |
| 문자열 → 래퍼 객체 | `valueOf("123")`                                   | `Integer` |
| 기본형 → 문자열    | `String.valueOf(123)` 또는 `Integer.toString(123)` | `"123"`   |
| 래퍼 객체 → 문자열 | `obj.toString()`                                   | `"123"`   |

------

### 🧪 예제 통합

```
String input = "42";

// 1. 문자열 → 기본형
int a = Integer.parseInt(input);

// 2. 문자열 → 객체
Integer b = Integer.valueOf(input);

// 3. 기본형 → 문자열
String s1 = Integer.toString(a);

// 4. 객체 → 문자열
String s2 = b.toString();

// 5. 문자열 → boolean
boolean tf = Boolean.parseBoolean("true");
```

------

### ⚠️ 주의사항

#### 🔸 `parseXXX()`는 NumberFormatException 발생 가능

```
Integer.parseInt("abc");  // ❌ 예외 발생
```

→ 항상 `try-catch` 또는 유효성 체크 필요

------

#### 🔸 `Boolean.parseBoolean()`의 특징

- `"true"` (대소문자 무시) → `true`
- `"false"`, `"abc"`, `null` → 모두 `false`

```
Boolean.parseBoolean("TRUE");   // true
Boolean.parseBoolean("yes");    // false
Boolean.parseBoolean(null);     // false
```

------

### ✅ 요약 표

| 메서드                        | 입력   | 출력      | 용도               |
| ----------------------------- | ------ | --------- | ------------------ |
| `parseInt("123")`             | 문자열 | `int`     | 문자열 숫자 → 정수 |
| `valueOf("123")`              | 문자열 | `Integer` | 문자열 숫자 → 객체 |
| `Integer.toString(123)`       | 정수   | 문자열    | 숫자 → 문자열      |
| `new Integer(123).toString()` | 객체   | 문자열    | 숫자 객체 → 문자열 |
| `String.valueOf(123.45)`      | double | 문자열    | 범용 숫자 → 문자열 |

## NumberFormat, DecimalFormat

Java에서 숫자를 **문자열로 포맷하거나**, 문자열을 **숫자로 파싱**할 때 사용하는 두 가지 핵심 클래스인

✅ `NumberFormat`
✅ `DecimalFormat`

을 **용도별, 기능별, 예제 중심**으로 정리한다.

### 🟦 1. `NumberFormat` – 숫자 포맷의 상위 추상 클래스

#### 🌟 개요

- `java.text.NumberFormat`
- 숫자, 통화(currency), 퍼센트(%) 등 다양한 **국제화 포맷** 지원
- 하위 클래스인 `DecimalFormat`이 실제 포맷 처리 담당
- **언어/국가별 숫자 표현 방식**을 자동으로 맞춤

------

#### ✅ 주요 메서드

| 메서드                  | 설명                     |
| ----------------------- | ------------------------ |
| `getInstance()`         | 기본 숫자 포맷 생성      |
| `getCurrencyInstance()` | 통화 포맷                |
| `getPercentInstance()`  | 퍼센트 포맷              |
| `format(Number)`        | 숫자 → 문자열            |
| `parse(String)`         | 문자열 → 숫자 (`Number`) |

------

#### 🔸 예시

```
import java.text.NumberFormat;
import java.util.Locale;

public class Main {
    public static void main(String[] args) throws Exception {
        NumberFormat nf = NumberFormat.getInstance(Locale.US);
        System.out.println(nf.format(1234567.89));  // 1,234,567.89

        NumberFormat cf = NumberFormat.getCurrencyInstance(Locale.KOREA);
        System.out.println(cf.format(5000));        // ₩5,000

        NumberFormat pf = NumberFormat.getPercentInstance();
        pf.setMinimumFractionDigits(1);
        System.out.println(pf.format(0.753));       // 75.3%
    }
}
```

------

### 🟩 2. `DecimalFormat` – 사용자 정의 숫자 포맷

#### 🌟 개요

- `NumberFormat`을 상속한 구체 클래스
- 숫자 포맷을 **패턴 문자열**로 정밀하게 정의 가능
- `"0"`, `"#"`, `"."`, `","`, `"E"`, `"%"`, `"¤"` 등의 **패턴 기호** 사용

------

#### ✅ 포맷 패턴 기호

| 기호 | 의미                     | 예시                              |
| ---- | ------------------------ | --------------------------------- |
| `0`  | 자릿수 채움 (0으로 채움) | `"0000"` → `42` → `0042`          |
| `#`  | 자릿수 표시 (0이면 생략) | `"###"` → `42` → `42`, `0` → `""` |
| `.`  | 소수점                   | `"0.00"` → `3.1` → `3.10`         |
| `,`  | 천 단위 구분             | `"#,###"` → `10000` → `10,000`    |
| `%`  | 퍼센트 변환              | `"0%"` → `0.25` → `25%`           |
| `¤`  | 통화 기호                | `"¤#,##0"` → `1000` → `₩1,000`    |

------

#### 🔸 예시

```
import java.text.DecimalFormat;

public class Main {
    public static void main(String[] args) {
        DecimalFormat df1 = new DecimalFormat("0.00");
        System.out.println(df1.format(3.1));        // 3.10

        DecimalFormat df2 = new DecimalFormat("#,###");
        System.out.println(df2.format(1234567));    // 1,234,567

        DecimalFormat df3 = new DecimalFormat("¤#,##0");
        df3.setCurrency(java.util.Currency.getInstance("KRW"));
        System.out.println(df3.format(1000));       // ₩1,000
    }
}
```

------

### 🧪 문자열 → 숫자 파싱

```
DecimalFormat df = new DecimalFormat("0.00");
Number n = df.parse("1234.56");
double d = n.doubleValue();
System.out.println(d);  // 1234.56
```

> `parse()`는 문자열 → `Number` → `int`, `double` 등으로 형변환 필요

------

### 🔁 `format()` vs `parse()` 비교

| 메서드           | 방향          | 예시                  |
| ---------------- | ------------- | --------------------- |
| `format(Number)` | 숫자 → 문자열 | `1234.5 → "1,234.50"` |
| `parse(String)`  | 문자열 → 숫자 | `"1,234.5" → 1234.5`  |

------

### ✅ 실전 활용 정리

| 상황             | 추천 클래스                   | 설명                          |
| ---------------- | ----------------------------- | ----------------------------- |
| 단순 숫자 포맷   | `NumberFormat.getInstance()`  | 기본 숫자                     |
| 통화 출력        | `getCurrencyInstance(Locale)` | `₩`, `$` 등                   |
| 퍼센트 포맷      | `getPercentInstance()`        | `0.25 → 25%`                  |
| 사용자 지정 형식 | `DecimalFormat("0.000")`      | 원하는 형태 직접 지정         |
| 입력 파싱        | `parse()`                     | 문자열을 숫자로 안전하게 변환 |

# 9.6 입출력 API (`java.io`, `java.nio`)

## InputStream, OutputStream, Reader, Writer

Java에서 **입출력(IO)** 을 처리하는 가장 근본적인 클래스들인

✅ `InputStream`, `OutputStream` (바이트 스트림)
✅ `Reader`, `Writer` (문자 스트림)

이 네 가지를 정리한다. 이들은 Java IO의 핵심이며, **파일 읽기, 네트워크 통신, 콘솔 입출력 등 모든 IO 처리의 기반**이다.

### 🔷 전체 구조 개요

Java IO는 크게 두 가지 계층으로 나뉘어:

| 스트림 종류   | 설명                   | 대표 클래스                   |
| ------------- | ---------------------- | ----------------------------- |
| 바이트 스트림 | 1바이트 단위 처리      | `InputStream`, `OutputStream` |
| 문자 스트림   | 문자(UTF-16) 단위 처리 | `Reader`, `Writer`            |

------

### 🟦 1. `InputStream` & `OutputStream` (바이트 기반)

#### 📌 특징

- **이미지, 파일, 바이너리 데이터 등**을 다룰 때 사용
- 1바이트(`byte`) 또는 바이트 배열로 입출력 처리
- 최상위 추상 클래스: `java.io.InputStream`, `java.io.OutputStream`

------

#### ✅ 주요 메서드 (`InputStream`)

| 메서드             | 설명                            |
| ------------------ | ------------------------------- |
| `int read()`       | 한 바이트 읽기 (0~255, EOF: -1) |
| `int read(byte[])` | 바이트 배열로 읽기              |
| `int available()`  | 읽을 수 있는 바이트 수          |
| `void close()`     | 스트림 닫기                     |

```
InputStream in = new FileInputStream("test.bin");
int data;
while ((data = in.read()) != -1) {
    System.out.print((char)data);
}
in.close();
```

------

#### ✅ 주요 메서드 (`OutputStream`)

| 메서드               | 설명           |
| -------------------- | -------------- |
| `void write(int b)`  | 한 바이트 쓰기 |
| `void write(byte[])` | 배열 쓰기      |
| `void flush()`       | 버퍼 비우기    |
| `void close()`       | 스트림 닫기    |

```
OutputStream out = new FileOutputStream("out.bin");
out.write("Hello".getBytes());
out.close();
```

------

### 🟩 2. `Reader` & `Writer` (문자 기반)

#### 📌 특징

- **텍스트, 유니코드 문자 처리**에 최적화
- `InputStreamReader`, `OutputStreamWriter` 로 바이트 ↔ 문자 변환 가능

------

#### ✅ 주요 메서드 (`Reader`)

| 메서드             | 설명                   |
| ------------------ | ---------------------- |
| `int read()`       | 한 문자 읽기 (EOF: -1) |
| `int read(char[])` | 문자 배열로 읽기       |
| `void close()`     | 닫기                   |

```
Reader reader = new FileReader("test.txt");
int ch;
while ((ch = reader.read()) != -1) {
    System.out.print((char) ch);
}
reader.close();
```

------

#### ✅ 주요 메서드 (`Writer`)

| 메서드               | 설명           |
| -------------------- | -------------- |
| `void write(int)`    | 문자 하나 출력 |
| `void write(String)` | 문자열 출력    |
| `void flush()`       | 버퍼 비우기    |
| `void close()`       | 닫기           |

```
Writer writer = new FileWriter("output.txt");
writer.write("안녕하세요!");
writer.close();
```

------

### 🔁 InputStream ↔ Reader 변환

- 문자 스트림은 내부적으로 바이트 스트림을 감싸서 동작
- **변환 클래스**: `InputStreamReader`, `OutputStreamWriter`

```
InputStream in = new FileInputStream("text.txt");
Reader reader = new InputStreamReader(in, "UTF-8");  // 인코딩 명시 가능
```

------

### 🔄 주요 서브클래스 요약

| 목적        | 입력                   | 출력                    |
| ----------- | ---------------------- | ----------------------- |
| 파일        | `FileInputStream`      | `FileOutputStream`      |
| 문자 파일   | `FileReader`           | `FileWriter`            |
| 메모리 버퍼 | `ByteArrayInputStream` | `ByteArrayOutputStream` |
| 문자 버퍼   | `CharArrayReader`      | `CharArrayWriter`       |
| 문자열      | `StringReader`         | `StringWriter`          |
| 변환        | `InputStreamReader`    | `OutputStreamWriter`    |
| 성능 개선   | `BufferedInputStream`  | `BufferedOutputStream`  |
| 문자 버퍼링 | `BufferedReader`       | `BufferedWriter`        |

------

### ✅ 정리 비교표

| 항목        | `InputStream` / `OutputStream` | `Reader` / `Writer`       |
| ----------- | ------------------------------ | ------------------------- |
| 단위        | 바이트(byte)                   | 문자(char)                |
| 인코딩 처리 | ❌ 없음                         | ✅ 필요                    |
| 사용 대상   | 이미지, 바이너리, PDF 등       | 텍스트 파일, JSON, XML 등 |
| 변환        | `InputStreamReader`            | `OutputStreamWriter`      |

## File, BufferedReader, PrintWriter

 Java IO에서 **파일을 직접 다루거나**, **텍스트 입출력을 효율적으로 처리**할 때 많이 사용하는 3가지 핵심 클래스이다.

✅ `File` – 파일 경로 및 메타 정보 관리
✅ `BufferedReader` – 문자 입력 버퍼링 (라인 단위 읽기)
✅ `PrintWriter` – 포맷팅된 출력 (문자 기반 쓰기)

### 🟦 1. `File` 클래스

#### 🌟 개요

- `java.io.File`
- 실제 파일, 디렉토리의 **경로를 추상화**한 객체
- 입출력은 하지 않지만, **파일 존재 여부, 크기, 경로, 삭제, 생성 등 메타 정보 조작**에 사용

------

#### ✅ 주요 생성자

```
new File("test.txt")
new File("/path/to", "file.txt")
```

------

#### ✅ 주요 메서드

| 메서드                                          | 설명                    |
| ----------------------------------------------- | ----------------------- |
| `exists()`                                      | 파일 존재 여부          |
| `createNewFile()`                               | 새 파일 생성            |
| `delete()`                                      | 파일 삭제               |
| `isFile()` / `isDirectory()`                    | 파일 or 디렉토리 구분   |
| `getName()` / `getPath()` / `getAbsolutePath()` | 파일 정보               |
| `length()`                                      | 파일 크기               |
| `listFiles()`                                   | 디렉토리 안의 파일 목록 |

------

#### 🔸 예시

```
import java.io.File;

public class Main {
    public static void main(String[] args) throws Exception {
        File file = new File("hello.txt");

        if (!file.exists()) {
            file.createNewFile();
            System.out.println("파일 생성됨");
        }

        System.out.println("파일 크기: " + file.length() + " bytes");
        System.out.println("절대 경로: " + file.getAbsolutePath());
    }
}
```

------

### 🟩 2. `BufferedReader`

#### 🌟 개요

- `java.io.BufferedReader`
- **문자 스트림을 버퍼링하여 성능 향상**
- **라인 단위 읽기 (`readLine()`)** 가능
- `Reader` 하위 클래스 (`FileReader`, `InputStreamReader` 등과 함께 사용)

------

#### ✅ 생성자

```
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
```

------

#### ✅ 주요 메서드

| 메서드       | 설명                            |
| ------------ | ------------------------------- |
| `read()`     | 한 문자 읽기                    |
| `readLine()` | 한 줄 읽기 (개행 문자는 제거됨) |
| `ready()`    | 읽을 데이터가 준비되었는지 확인 |
| `close()`    | 스트림 닫기                     |

------

#### 🔸 예시

```
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader("data.txt"));
        String line;

        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }

        reader.close();
    }
}
```

------

### 🟨 3. `PrintWriter`

#### 🌟 개요

- `java.io.PrintWriter`
- `Writer` 하위 클래스
- **포맷팅된 문자 출력**, 자동 개행, `System.out` 대체 가능
- 내부적으로 `BufferedWriter`를 사용

------

#### ✅ 생성자

```
PrintWriter pw = new PrintWriter("output.txt");              // 기본 생성
PrintWriter pw = new PrintWriter(new FileWriter("a.txt"));   // 버퍼링 없이
PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("a.txt"))); // 고속
```

------

#### ✅ 주요 메서드

| 메서드                    | 설명                                   |
| ------------------------- | -------------------------------------- |
| `print()`, `println()`    | 출력 및 줄바꿈                         |
| `printf(format, args...)` | 포맷 출력 (`System.out.printf`와 동일) |
| `write()`                 | 문자 단위 출력                         |
| `flush()`                 | 버퍼 비움                              |
| `close()`                 | 스트림 닫기                            |

------

#### 🔸 예시

```
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter writer = new PrintWriter("output.txt");

        writer.println("첫 줄입니다.");
        writer.printf("숫자: %d, 실수: %.2f\n", 42, 3.14);

        writer.close();  // flush 포함됨
    }
}
```

------

### 🧠 실전 예제: `BufferedReader + PrintWriter` 조합

```
BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
PrintWriter writer = new PrintWriter("output.txt");

String line;
while ((line = reader.readLine()) != null) {
    writer.println("읽은 줄: " + line);
}

reader.close();
writer.close();
```

------

### ✅ 요약 비교표

| 클래스           | 목적               | 주요 기능                           |
| ---------------- | ------------------ | ----------------------------------- |
| `File`           | 파일/디렉토리 정보 | 경로, 존재 확인, 삭제, 생성         |
| `BufferedReader` | 입력 성능 향상     | 줄 단위 읽기, 버퍼링                |
| `PrintWriter`    | 출력 성능 + 편의성 | print, println, printf 지원, 버퍼링 |

## Files, Paths, ByteBuffer, FileChannel (NIO)

Java NIO(New I/O)에서 파일 입출력을 처리하기 위해 사용하는 핵심 클래스들인
 ✅ `Files`
 ✅ `Paths`
 ✅ `ByteBuffer`
 ✅ `FileChannel`
 을 정리한다. 이들은 **전통적인 IO보다 빠르고 유연한 고성능 입출력 방식**을 제공하며, 대용량 파일 처리나 메모리 매핑, 버퍼 기반 처리가 필요할 때 특히 유용하다.

### 🟦 1. `Paths`

#### 🌟 개요

- `java.nio.file.Paths`: 경로를 나타내는 객체
- `Path` 객체를 만들기 위한 헬퍼 클래스
- `File`보다 더 유연하고 OS 독립적인 경로 조작 가능

#### ✅ 예시

```
import java.nio.file.*;

Path path = Paths.get("data", "example.txt");  // 경로 연결
System.out.println(path.toAbsolutePath());     // 절대 경로 출력
System.out.println(Files.exists(path));        // 존재 여부
```

------

### 🟩 2. `Files`

#### 🌟 개요

- `java.nio.file.Files`: **파일 조작 기능 모음 (정적 메서드)**
- `Path` 객체 기반으로 파일을 읽고 쓰거나, 복사, 삭제, 이동 등 수행

#### ✅ 주요 메서드

| 메서드                         | 설명                              |
| ------------------------------ | --------------------------------- |
| `readAllLines(Path)`           | 모든 줄을 `List<String>`으로 읽기 |
| `readAllBytes(Path)`           | 파일을 byte[]로 읽기              |
| `write(Path, byte[])`          | byte[]를 파일에 쓰기              |
| `copy()`, `move()`, `delete()` | 파일 복사, 이동, 삭제             |
| `isDirectory()`, `exists()`    | 파일 상태 확인                    |
| `lines(Path)`                  | `Stream<String>` 반환             |

------

#### 🔸 예시: 파일 쓰고 읽기

```
Path path = Paths.get("sample.txt");

// 쓰기
Files.write(path, "Hello, NIO!".getBytes());

// 읽기
String content = Files.readString(path);  // Java 11+
System.out.println(content);
```

------

### 🟨 3. `ByteBuffer`

#### 🌟 개요

- `java.nio.ByteBuffer`: **바이트 데이터를 읽고 쓰기 위한 버퍼**
- `FileChannel`, `SocketChannel` 등과 함께 사용
- **직접 할당 (`allocateDirect`)** vs **JVM 메모리 (`allocate`)**

------

#### ✅ 주요 메서드

| 메서드                     | 설명                        |
| -------------------------- | --------------------------- |
| `allocate(int)`            | JVM 힙 메모리에 버퍼 생성   |
| `allocateDirect(int)`      | OS 메모리(Direct 메모리)    |
| `put(byte)`, `put(byte[])` | 데이터 쓰기                 |
| `get()`, `get(byte[])`     | 데이터 읽기                 |
| `flip()`                   | 읽기 모드로 전환            |
| `clear()`                  | 쓰기 모드로 초기화          |
| `rewind()`                 | 읽기 위치를 처음으로 되돌림 |

------

#### 🔸 예시

```
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put("Hello ByteBuffer".getBytes());
buffer.flip();

while (buffer.hasRemaining()) {
    System.out.print((char) buffer.get());
}
```

------

### 🟥 4. `FileChannel`

#### 🌟 개요

- `java.nio.channels.FileChannel`: **파일에 직접 접근 가능한 채널**
- RandomAccessFile, FileInputStream, FileOutputStream으로부터 생성
- **seek, position, truncate, memory-mapped I/O** 지원

------

#### ✅ 주요 메서드

| 메서드              | 설명                     |
| ------------------- | ------------------------ |
| `read(ByteBuffer)`  | 버퍼로 읽기              |
| `write(ByteBuffer)` | 버퍼에서 쓰기            |
| `position()`        | 읽기/쓰기 위치 확인      |
| `size()`            | 파일 크기 반환           |
| `truncate(long)`    | 파일 크기 자르기         |
| `map()`             | 메모리 맵핑 I/O (고성능) |

------

#### 🔸 예시: 버퍼 + 채널을 이용한 파일 복사

```
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class Main {
    public static void main(String[] args) throws IOException {
        try (
            FileInputStream fis = new FileInputStream("source.txt");
            FileOutputStream fos = new FileOutputStream("dest.txt");
            FileChannel inChannel = fis.getChannel();
            FileChannel outChannel = fos.getChannel()
        ) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            while (inChannel.read(buffer) > 0) {
                buffer.flip();
                outChannel.write(buffer);
                buffer.clear();
            }
        }
    }
}
```

------

### 🔁 정리 비교표

| 클래스        | 설명                    | 주요 용도                             |
| ------------- | ----------------------- | ------------------------------------- |
| `Paths`       | `Path` 객체 생성 도우미 | 경로 조작                             |
| `Files`       | 정적 메서드로 파일 처리 | 간단한 읽기/쓰기/삭제                 |
| `ByteBuffer`  | 바이트 저장/조작용 버퍼 | 채널 기반 입출력                      |
| `FileChannel` | 파일 직접 접근 채널     | 대용량 파일, 버퍼 입출력, 메모리 매핑 |

------

### ✅ 요약 예시: "파일 → ByteBuffer → 채널 → 파일"

```
Path source = Paths.get("source.txt");
Path dest = Paths.get("copy.txt");

try (
    FileChannel in = FileChannel.open(source);
    FileChannel out = FileChannel.open(dest, StandardOpenOption.CREATE, StandardOpenOption.WRITE)
) {
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    while (in.read(buffer) > 0) {
        buffer.flip();
        out.write(buffer);
        buffer.clear();
    }
}
```

## 객체 직렬화: Serializable, ObjectInputStream 등

Java에서 객체를 파일, 네트워크 등으로 저장하거나 전송할 수 있도록 만드는 기능인
✅ **객체 직렬화(Serialization)** 에 대해 정리해준다.

이 기능은 다음 요소들로 구성된다:

- ✅ `Serializable` 인터페이스
- ✅ `ObjectOutputStream` (객체를 저장/전송)
- ✅ `ObjectInputStream` (객체를 복원/수신)
- ⛔ 직렬화 대상 제외: `transient` 키워드
- 💡 직렬 버전 관리: `serialVersionUID`

### 🟦 1. 객체 직렬화(Serialization)란?

> **객체의 상태(state)를 바이트 형태로 변환하여 저장하거나 전송할 수 있게 하는 것**

📦 직렬화 → 파일/네트워크로 전송
 🔁 역직렬화 → 저장된 바이트 데이터를 다시 객체로 복원

------

### 🟩 2. `Serializable` 인터페이스

#### 🌟 개요

- `java.io.Serializable`은 **마커 인터페이스** (메서드 없음)
- 이 인터페이스를 구현한 객체만 직렬화할 수 있음

```
import java.io.Serializable;

public class User implements Serializable {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

------

### 🟨 3. `ObjectOutputStream` & `ObjectInputStream`

#### ✅ 객체 저장 (직렬화)

```
import java.io.*;

User user = new User("Alice", 30);
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"));
oos.writeObject(user);
oos.close();
```

#### ✅ 객체 복원 (역직렬화)

```
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"));
User restored = (User) ois.readObject();
ois.close();

System.out.println(restored.getName());
```

------

### ⚠️ 4. transient 키워드

> 직렬화 대상에서 **제외하고 싶은 필드**에 사용

```
class User implements Serializable {
    private String name;
    private transient String password; // 저장되지 않음
}
```

------

### 🧠 5. serialVersionUID

> 클래스의 버전을 식별하는 정수값.
>  직렬화된 객체를 **정확히 복원하기 위한 ID**.

```
private static final long serialVersionUID = 1L;
```

- 자동으로 부여되지만, 클래스 구조가 바뀌면 **호환되지 않음**
- 명시적으로 선언해서 버전 충돌 방지

------

### 🧪 실전 예제: 직렬화 + 역직렬화 전체 흐름

```
class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private transient String secret;

    public Person(String name, String secret) {
        this.name = name;
        this.secret = secret;
    }

    @Override
    public String toString() {
        return name + ", secret=" + secret;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        // 직렬화
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("person.ser"));
        out.writeObject(new Person("Bob", "1234"));
        out.close();

        // 역직렬화
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("person.ser"));
        Person p = (Person) in.readObject();
        in.close();

        System.out.println(p);  // secret=null (transient 적용됨)
    }
}
```

------

### 🔁 `Serializable` vs `Externalizable`

| 항목              | `Serializable`  | `Externalizable`                    |
| ----------------- | --------------- | ----------------------------------- |
| 방식              | 자동 직렬화     | 개발자가 수동으로 제어              |
| 성능              | 상대적으로 느림 | 빠름 (직접 구현)                    |
| 인터페이스 메서드 | 없음            | `writeExternal()`, `readExternal()` |
| 사용성            | 매우 간편       | 고급 제어 가능                      |

------

### ✅ 요약 정리표

| 개념                 | 설명                       |
| -------------------- | -------------------------- |
| `Serializable`       | 직렬화 대상임을 표시       |
| `ObjectOutputStream` | 객체 → 파일/바이트로 저장  |
| `ObjectInputStream`  | 바이트 → 객체로 복원       |
| `transient`          | 직렬화 대상 제외 필드      |
| `serialVersionUID`   | 클래스 버전 ID (명시 권장) |

# 9.7 기타 주요 API 개요

## `java.util.concurrent`: Executor, Future, Lock 등

 Java의 고성능 동시성 프로그래밍을 위한 핵심 패키지인
✅ `java.util.concurrent`에 대해 정리한다.

이 패키지는 멀티스레드 환경에서 **더 안전하고 유연하게 작업을 분산, 조율, 동기화**할 수 있게 도와주는 다양한 도구들을 제공한다.

### 🟦 1. 주요 구성 요소 개요

| 범주               | 주요 클래스 / 인터페이스                                    | 설명                              |
| ------------------ | ----------------------------------------------------------- | --------------------------------- |
| **스레드 풀**      | `Executor`, `ExecutorService`, `ThreadPoolExecutor`         | 스레드 풀 기반 작업 실행          |
| **작업 결과 처리** | `Future`, `Callable`                                        | 비동기 작업 실행 및 결과 조회     |
| **락/동기화**      | `Lock`, `ReentrantLock`, `ReadWriteLock`                    | 고급 동기화 제어                  |
| **동시성 컬렉션**  | `ConcurrentHashMap`, `CopyOnWriteArrayList`                 | 멀티스레드 환경에서 안전한 컬렉션 |
| **스케줄링**       | `ScheduledExecutorService`                                  | 정기적/지연 작업 스케줄링         |
| **동기화 도구**    | `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger` | 스레드 간 협업 제어               |

------

### 🟨 2. Executor, ExecutorService

#### 🌟 기본 구조

```
Executor executor = Executors.newSingleThreadExecutor();
executor.execute(() -> System.out.println("Hello Executor!"));
```

#### 🌟 `ExecutorService` - 결과 처리와 종료 지원

```
ExecutorService service = Executors.newFixedThreadPool(4);
service.submit(() -> {
    System.out.println("작업 실행 중");
});
service.shutdown();
```

------

### 🟩 3. Callable & Future

#### ✅ Callable: `Runnable`과 달리 **값을 반환**함

```
Callable<Integer> task = () -> {
    return 5 + 10;
};
```

#### ✅ Future: 비동기 작업의 결과를 받을 수 있음

```
ExecutorService pool = Executors.newSingleThreadExecutor();
Future<Integer> future = pool.submit(task);

Integer result = future.get(); // 블로킹 호출
System.out.println(result);
pool.shutdown();
```

------

### 🟥 4. Lock 인터페이스

#### ✅ 기본 Lock 사용

```
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 임계 영역
} finally {
    lock.unlock();
}
```

#### ✅ 주요 메서드

| 메서드                | 설명                     |
| --------------------- | ------------------------ |
| `lock()`              | 락 획득 (블로킹)         |
| `tryLock()`           | 락 시도 (즉시 실패 가능) |
| `unlock()`            | 락 해제                  |
| `lockInterruptibly()` | 인터럽트 가능한 락       |

------

### 🟦 5. ReadWriteLock

- 읽기 작업은 동시에 가능, 쓰기 작업은 단독으로 실행됨

```
ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();
// 공유 자원 읽기
rwLock.readLock().unlock();
```

------

### 🟨 6. Concurrent 컬렉션

| 컬렉션                                                       | 설명                            |
| ------------------------------------------------------------ | ------------------------------- |
| `ConcurrentHashMap`                                          | 쓰레드 안전한 해시맵            |
| `CopyOnWriteArrayList`                                       | 읽기 빈도 높고 쓰기 적은 리스트 |
| `ConcurrentLinkedQueue`                                      | 락 없는 대기열                  |
| `BlockingQueue` (`LinkedBlockingQueue`, `ArrayBlockingQueue`) | 생산자-소비자 패턴에 유용       |

```
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("one", 1);
System.out.println(map.get("one"));
```

------

### 🟩 7. 동기화 도구

| 도구             | 설명                             |
| ---------------- | -------------------------------- |
| `CountDownLatch` | 여러 스레드 작업 완료 대기       |
| `CyclicBarrier`  | 여러 스레드가 동시에 다음 단계로 |
| `Semaphore`      | 리소스 접근 동시 개수 제한       |
| `Exchanger`      | 두 스레드 간 데이터 교환         |

```
CountDownLatch latch = new CountDownLatch(3);

Runnable task = () -> {
    // 작업 수행
    latch.countDown();
};

for (int i = 0; i < 3; i++) new Thread(task).start();
latch.await();  // 모든 스레드가 끝날 때까지 대기
```

------

### ✅ 실전 예제: 멀티스레드 작업 + Future + 락

```
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

class Counter {
    private int count = 0;
    private Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int get() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Counter counter = new Counter();
        ExecutorService pool = Executors.newFixedThreadPool(5);

        Callable<Void> task = () -> {
            for (int i = 0; i < 1000; i++) counter.increment();
            return null;
        };

        List<Future<Void>> futures = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            futures.add(pool.submit(task));
        }

        for (Future<Void> f : futures) f.get();

        pool.shutdown();
        System.out.println("최종 카운트: " + counter.get());
    }
}
```

------

### 🧠 핵심 요약

| 개념                          | 설명                      |
| ----------------------------- | ------------------------- |
| `Executor`                    | 작업 실행 인터페이스      |
| `Future`                      | 비동기 결과 확인 도구     |
| `Lock`, `ReadWriteLock`       | 고급 동기화 제어          |
| `ConcurrentHashMap`           | 병렬 환경에서도 안전한 맵 |
| `CountDownLatch`, `Semaphore` | 스레드 협력/제어 도구     |

## `java.sql`: JDBC와 DB 연동

Java에서 데이터베이스와 연결하는 표준 API인
✅ `java.sql` 기반 **JDBC(Java Database Connectivity)** 를 깊이 있게 다뤄본다.

### 🟦 1. JDBC란?

> Java에서 관계형 데이터베이스(RDBMS)와 연결하여 SQL을 실행하고 결과를 처리할 수 있게 해주는 API

#### 🎯 주요 기능:

- DB 연결 (Connection)
- SQL 실행 (Statement / PreparedStatement)
- 결과 처리 (ResultSet)
- 트랜잭션 처리
- 자원 정리

------

### 🟨 2. JDBC 주요 클래스 구조

| 계층 | 클래스 / 인터페이스                                   | 설명                 |
| ---- | ----------------------------------------------------- | -------------------- |
| 연결 | `Driver`, `DriverManager`, `Connection`               | DB 연결 및 세션 생성 |
| 실행 | `Statement`, `PreparedStatement`, `CallableStatement` | SQL 실행             |
| 결과 | `ResultSet`                                           | 쿼리 결과 탐색       |
| 설정 | `ResultSetMetaData`, `DatabaseMetaData`               | DB 및 결과 정보      |
| 기타 | `SQLException`, `BatchUpdateException` 등             | 예외 처리            |

------

### 🟩 3. JDBC 사용 단계 요약

#### 1️⃣ 드라이버 로딩

```
Class.forName("com.mysql.cj.jdbc.Driver"); // 최신 JDBC 드라이버는 생략 가능
```

#### 2️⃣ DB 연결

```
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "username", "password"
);
```

#### 3️⃣ SQL 실행

```
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```

#### 4️⃣ 결과 처리

```
while (rs.next()) {
    System.out.println(rs.getString("name"));
}
```

#### 5️⃣ 자원 해제

```
rs.close();
stmt.close();
conn.close();
```

------

### 🟥 4. PreparedStatement 사용 (권장)

```
String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, 10);
ResultSet rs = pstmt.executeQuery();
```

#### 📌 장점:

- SQL 인젝션 방지
- 성능 향상 (쿼리 캐시)
- 가독성 향상

------

### 🟦 5. 트랜잭션 처리

```
conn.setAutoCommit(false); // 수동 트랜잭션 시작

try {
    // 여러 쿼리 수행
    conn.commit(); // 성공 시 커밋
} catch (Exception e) {
    conn.rollback(); // 실패 시 롤백
}
```

------

### 🟨 6. ResultSet 결과 탐색

| 메서드                   | 설명             |
| ------------------------ | ---------------- |
| `rs.next()`              | 다음 행으로 이동 |
| `rs.getString("컬럼명")` | 문자열 조회      |
| `rs.getInt("컬럼명")`    | 정수 조회        |
| `rs.getDate("컬럼명")`   | 날짜 조회        |
| `rs.wasNull()`           | NULL 여부 확인   |

------

### 🟩 7. 자주 쓰는 JDBC URL 예시

| DBMS       | URL 예시                                  |
| ---------- | ----------------------------------------- |
| MySQL      | `jdbc:mysql://localhost:3306/dbname`      |
| PostgreSQL | `jdbc:postgresql://localhost:5432/dbname` |
| Oracle     | `jdbc:oracle:thin:@localhost:1521:xe`     |
| H2         | `jdbc:h2:mem:testdb`                      |

------

### 🧪 예제 코드 (MySQL 기준)

```
import java.sql.*;

public class JdbcExample {
    public static void main(String[] args) throws Exception {
        Class.forName("com.mysql.cj.jdbc.Driver");
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/testdb", "root", "password");
             PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {

            pstmt.setInt(1, 1);
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    System.out.println("이름: " + rs.getString("name"));
                }
            }
        }
    }
}
```

------

### 🧠 고급 개념 요약

| 항목                 | 설명                                                        |
| -------------------- | ----------------------------------------------------------- |
| `Batch`              | 다수의 쿼리 묶음 실행 (`addBatch()`, `executeBatch()`)      |
| `Connection Pool`    | 재사용 가능한 연결 관리 (ex. HikariCP)                      |
| `Metadata`           | DB 구조/정보 탐색 (`DatabaseMetaData`, `ResultSetMetaData`) |
| `CallableStatement`  | 저장 프로시저 호출                                          |
| `try-with-resources` | 자원 자동 해제 구조 (Java 7+)                               |

------

### ✅ JDBC 실전 팁

- 항상 `PreparedStatement`를 사용할 것
- `try-with-resources`로 연결 누수 방지
- 트랜잭션 경계 (`commit/rollback`)는 명확하게
- 커넥션 풀 라이브러리(HikariCP, Apache DBCP)와 함께 사용 권장

## `java.net`: Socket, URL 등 네트워크 프로그래밍

### 🟦 1. `java.net` 패키지 개요

Java의 `java.net`은 **TCP/IP 기반 네트워크 프로그래밍**을 위한 기본 API를 제공하며, 다음 기능을 포함해:

- 소켓 통신 (TCP/UDP)
- URL 접근 및 웹 데이터 수신
- 서버 및 클라이언트 구현
- HTTP/FTP 등 프로토콜 핸들링

------

### 🟨 2. 소켓 통신 개요 (TCP 기반)

#### 🔸 기본 구조

| 역할       | 클래스         | 설명                        |
| ---------- | -------------- | --------------------------- |
| 클라이언트 | `Socket`       | 서버에 연결 요청            |
| 서버       | `ServerSocket` | 연결 수락 및 통신 소켓 반환 |

------

### 🟩 3. TCP 클라이언트 예제 (`Socket` 사용)

```
import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) throws IOException {
        try (Socket socket = new Socket("localhost", 12345);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

            out.println("Hello from client");
            String response = in.readLine();
            System.out.println("서버 응답: " + response);
        }
    }
}
```

------

### 🟥 4. TCP 서버 예제 (`ServerSocket` 사용)

```
import java.io.*;
import java.net.*;

public class Server {
    public static void main(String[] args) throws IOException {
        try (ServerSocket serverSocket = new ServerSocket(12345)) {
            System.out.println("서버 대기 중...");

            try (Socket clientSocket = serverSocket.accept();
                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

                String message = in.readLine();
                System.out.println("클라이언트로부터 받은 메시지: " + message);
                out.println("Hello Client!");
            }
        }
    }
}
```

------

### 🟦 5. URL 클래스: 웹 자원 접근

```
import java.io.*;
import java.net.*;

public class UrlExample {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://example.com");
        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));

        String line;
        while ((line = in.readLine()) != null) {
            System.out.println(line);
        }
        in.close();
    }
}
```

#### 📌 URL 주요 메서드

| 메서드          | 설명                              |
| --------------- | --------------------------------- |
| `getProtocol()` | 프로토콜 (`http`, `https`, `ftp`) |
| `getHost()`     | 호스트 이름                       |
| `getPort()`     | 포트 번호                         |
| `getPath()`     | 경로                              |
| `openStream()`  | 입력 스트림 반환 (GET 요청)       |

------

### 🟨 6. UDP 통신 (비연결형)

#### 클라이언트: `DatagramSocket`, `DatagramPacket`

```
DatagramSocket socket = new DatagramSocket();
InetAddress address = InetAddress.getByName("localhost");
byte[] buf = "Hello UDP".getBytes();

DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 12345);
socket.send(packet);
```

#### 서버:

```
DatagramSocket socket = new DatagramSocket(12345);
byte[] buf = new byte[256];

DatagramPacket packet = new DatagramPacket(buf, buf.length);
socket.receive(packet);
System.out.println("수신 메시지: " + new String(packet.getData()));
```

------

### 🟩 7. 고급 기능

| 기능           | 클래스                                  | 설명                     |
| -------------- | --------------------------------------- | ------------------------ |
| IP 정보 확인   | `InetAddress`                           | 도메인/IP 확인           |
| 멀티캐스트     | `MulticastSocket`                       | 다수 대상에 브로드캐스트 |
| 프록시 설정    | `Proxy`                                 | 프록시 서버 통한 요청    |
| 연결 시간 설정 | `HttpURLConnection.setConnectTimeout()` | 타임아웃 제어            |

------

### ✅ 실전 팁

- TCP는 신뢰성 있는 연결, UDP는 빠르지만 순서보장 없음
- 서버는 항상 `accept()` 후 멀티스레드로 클라이언트 처리
- URL 클래스는 간단한 웹 크롤링/REST API 사용에 적합
- Java 11+ 부터는 `HttpClient` 사용이 권장됨 (REST API 사용 시)

------

### 📌 요약 비교

| 항목      | TCP (`Socket`)  | UDP (`DatagramSocket`) |
| --------- | --------------- | ---------------------- |
| 연결 방식 | 연결형          | 비연결형               |
| 신뢰성    | 보장됨          | 보장되지 않음          |
| 전송 속도 | 느림            | 빠름                   |
| 사용 목적 | 채팅, 파일 전송 | 스트리밍, 브로드캐스트 |

## `java.util.stream`: Stream API

### 🟦 1. Stream API란?

> 데이터 소스를 추상화하여 **함수형 스타일로 처리**할 수 있도록 제공하는 Java 8의 API
>  📌 `java.util.stream` 패키지에 포함

- 데이터 컬렉션(List, Set 등)을 **선언적 방식**으로 처리
- 내부 반복 사용 → 명령형 for-loop보다 **가독성/효율성 우수**
- 병렬 처리 지원 → `parallelStream()`

------

### 🟨 2. Stream의 특징

| 특징                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **파이프라인 처리** | 연산들이 연결되어 한 흐름에서 작동 (`map().filter().collect()`) |
| **지연 연산**       | 중간 연산은 실제 계산을 미루며 최종 연산 시 실행됨           |
| **무상태/불변성**   | 데이터 소스를 변경하지 않고, 새 값을 리턴함                  |
| **병렬 처리 가능**  | `parallelStream()` 사용 시 내부적으로 ForkJoinPool 활용      |

------

### 🟩 3. Stream 생성 방법

```
// 컬렉션 기반
List<String> list = List.of("a", "b", "c");
Stream<String> stream1 = list.stream();

// 배열 기반
String[] arr = {"x", "y", "z"};
Stream<String> stream2 = Arrays.stream(arr);

// 값 직접
Stream<Integer> stream3 = Stream.of(1, 2, 3);

// 무한 스트림
Stream<Integer> stream4 = Stream.iterate(0, n -> n + 2); // 0, 2, 4, ...
Stream<Double> stream5 = Stream.generate(Math::random);
```

------

### 🟧 4. 중간 연산 (Intermediate Operations)

| 메서드              | 설명                        |
| ------------------- | --------------------------- |
| `filter(Predicate)` | 조건을 만족하는 요소만 통과 |
| `map(Function)`     | 각 요소를 다른 값으로 매핑  |
| `flatMap(Function)` | 중첩된 구조를 평탄화        |
| `distinct()`        | 중복 제거                   |
| `sorted()`          | 정렬                        |
| `limit(n)`          | n개까지만 자르기            |
| `skip(n)`           | 처음 n개 건너뛰기           |
| `peek(Consumer)`    | 디버깅용 중간 확인          |

🧪 예시:

```
list.stream()
    .filter(s -> s.length() > 2)
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);
```

------

### 🟥 5. 최종 연산 (Terminal Operations)

| 메서드                                    | 설명                      |
| ----------------------------------------- | ------------------------- |
| `forEach(Consumer)`                       | 각 요소에 작업 수행       |
| `collect(Collector)`                      | 리스트, 셋 등으로 수집    |
| `reduce(...)`                             | 누적 계산 수행            |
| `count()`                                 | 요소 수 반환              |
| `min()`, `max()`                          | 최소, 최대값 반환         |
| `anyMatch()`, `allMatch()`, `noneMatch()` | 조건 만족 여부 판단       |
| `findFirst()`, `findAny()`                | 요소 하나 반환 (Optional) |

🧪 예시:

```
int sum = List.of(1, 2, 3).stream().reduce(0, Integer::sum);
long count = list.stream().filter(s -> !s.isEmpty()).count();
```

------

### 🟨 6. Collectors 클래스와 수집 연산

```
List<String> result = list.stream()
                          .filter(s -> s.length() > 3)
                          .collect(Collectors.toList());
```

#### 주요 Collectors

| 메서드                       | 설명                    |
| ---------------------------- | ----------------------- |
| `toList()`, `toSet()`        | 컬렉션 수집             |
| `joining(", ")`              | 문자열 연결             |
| `groupingBy(Function)`       | 그룹핑 (Map<key, List>) |
| `partitioningBy(Predicate)`  | 조건 기반 2분할         |
| `counting()`, `summingInt()` | 수치 집계               |
| `mapping()`                  | 매핑 후 collect         |

🧪 그룹핑 예시:

```
Map<Integer, List<String>> grouped = list.stream()
    .collect(Collectors.groupingBy(String::length));
```

------

### 🟩 7. Optional + Stream 조합

```
Optional<String> opt = list.stream()
    .filter(s -> s.startsWith("A"))
    .findFirst();
```

------

### 🟦 8. 병렬 스트림 (Parallel Stream)

```
list.parallelStream()
    .map(String::toLowerCase)
    .forEach(System.out::println);
```

- 내부적으로 `ForkJoinPool` 사용
- 데이터 의존성이 없는 연산에 적합
- 병렬성에 따른 부작용/성능 고려 필요

------

### 🟪 9. flatMap vs map 비교

```
List<List<String>> nested = List.of(List.of("a", "b"), List.of("c"));
List<String> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
```

| 연산        | 설명                       |
| ----------- | -------------------------- |
| `map()`     | 요소 1:1 변환              |
| `flatMap()` | 요소 1:N → 1:1 평탄화 변환 |

------

### ✅ 실무 팁 요약

- `stream().filter().map().collect()` 패턴에 익숙해질 것
- `peek()`은 디버깅용으로만 사용할 것
- `Optional`과 함께 쓰면 안전한 연산 가능
- Stream은 단 한 번만 소비됨 (재사용 불가)
- 성능이 중요하면 `for`문과 비교 벤치마크 필수
- `Collectors.groupingBy()`를 적극 활용할 것

## `java.util.function`: 함수형 인터페이스

### 🟦 1. 함수형 인터페이스란?

> **하나의 추상 메서드만 가지는 인터페이스**
>  → 람다식 또는 메서드 참조의 대상이 될 수 있음
>  → `@FunctionalInterface` 어노테이션으로 명시 가능 (선택적)

#### 예시

```
@FunctionalInterface
interface MyFunc {
    int apply(int x); // 단 하나의 추상 메서드
}
```

```
MyFunc square = x -> x * x;
System.out.println(square.apply(5)); // 25
```

------

### 🟨 2. 주요 함수형 인터페이스 4종

| 인터페이스       | 메서드              | 설명                      |
| ---------------- | ------------------- | ------------------------- |
| `Function<T, R>` | `R apply(T t)`      | T를 받아 R을 리턴         |
| `Consumer<T>`    | `void accept(T t)`  | T를 소비(출력/저장 등)    |
| `Supplier<T>`    | `T get()`           | 아무것도 받지 않고 T 반환 |
| `Predicate<T>`   | `boolean test(T t)` | T를 받아 boolean 판단     |

------

### 🟩 3. `Function<T, R>` 예제

```
Function<String, Integer> strLength = s -> s.length();
System.out.println(strLength.apply("hello")); // 5
```

#### 함수 합성

```
Function<Integer, Integer> f1 = x -> x + 1;
Function<Integer, Integer> f2 = x -> x * 2;

Function<Integer, Integer> composed = f1.andThen(f2);
System.out.println(composed.apply(3)); // (3+1)*2 = 8
```

------

### 🟧 4. `Consumer<T>` 예제

```
Consumer<String> printer = s -> System.out.println("출력: " + s);
printer.accept("Hello"); // 출력: Hello
```

#### `andThen()` 체이닝 가능

```
Consumer<String> c1 = s -> System.out.println("1: " + s);
Consumer<String> c2 = s -> System.out.println("2: " + s);
c1.andThen(c2).accept("Test");
```

------

### 🟥 5. `Supplier<T>` 예제

```
Supplier<Double> randomSupplier = () -> Math.random();
System.out.println(randomSupplier.get());
```

- 주로 **초기화 지연**, **랜덤 값**, **캐시**, **객체 생성 지연** 등에 사용

------

### 🟪 6. `Predicate<T>` 예제

```
Predicate<String> isEmpty = s -> s.isEmpty();
System.out.println(isEmpty.test("")); // true
```

#### 조합 메서드

| 메서드     | 의미     |
| ---------- | -------- |
| `and()`    | AND 조건 |
| `or()`     | OR 조건  |
| `negate()` | NOT 조건 |

```
Predicate<String> isNotEmpty = isEmpty.negate();
System.out.println(isNotEmpty.test("abc")); // true
```

------

### 🟦 7. 기본형 특화 인터페이스

| 인터페이스                         | 기본형          | 설명 |
| ---------------------------------- | --------------- | ---- |
| `IntFunction<R>`                   | `int` → `R`     |      |
| `ToIntFunction<T>`                 | `T` → `int`     |      |
| `IntSupplier`, `DoubleSupplier` 등 | 반환값만 기본형 |      |
| `IntPredicate`, `LongPredicate` 등 | 입력만 기본형   |      |

🧪 예시:

```
IntPredicate isEven = x -> x % 2 == 0;
System.out.println(isEven.test(4)); // true
```

------

### 🟨 8. Bi계열 인터페이스

| 인터페이스            | 메서드               | 설명            |
| --------------------- | -------------------- | --------------- |
| `BiFunction<T, U, R>` | `R apply(T, U)`      | 두 값 → 한 결과 |
| `BiConsumer<T, U>`    | `void accept(T, U)`  | 두 값 소비      |
| `BiPredicate<T, U>`   | `boolean test(T, U)` | 두 값 조건 판별 |

```
BiFunction<String, Integer, String> repeat = (s, n) -> s.repeat(n);
System.out.println(repeat.apply("Hi", 3)); // HiHiHi
```

------

### 🟩 9. UnaryOperator, BinaryOperator

#### 🔹 `UnaryOperator<T>` = `Function<T, T>`

```
UnaryOperator<Integer> square = x -> x * x;
```

#### 🔹 `BinaryOperator<T>` = `(T, T) -> T`

```
BinaryOperator<Integer> sum = (a, b) -> a + b;
```

🧪 `reduce()`와 궁합 좋음:

```
int result = List.of(1, 2, 3).stream().reduce(0, Integer::sum);
```

------

### 🟧 10. 실무 활용 예시

#### ✅ Stream과 함께

```
List<String> names = List.of("a", "bb", "ccc");

List<Integer> lengths = names.stream()
    .filter(s -> s.length() > 1)             // Predicate
    .map(s -> s.length())                    // Function
    .collect(Collectors.toList());           // Collector
```

------

### ✅ 정리 요약

| 역할        | 인터페이스          | 설명           |
| ----------- | ------------------- | -------------- |
| T → R       | `Function<T, R>`    | 변환           |
| T → void    | `Consumer<T>`       | 소비           |
| () → T      | `Supplier<T>`       | 공급           |
| T → boolean | `Predicate<T>`      | 조건 판별      |
| T → T       | `UnaryOperator<T>`  | 동일 타입 변환 |
| (T, T) → T  | `BinaryOperator<T>` | 동일 타입 연산 |

## `java.lang.reflect`: 리플렉션 API

### 🟦 1. 리플렉션(Reflection)이란?

> **런타임에 클래스/메서드/필드 등의 정보를 동적으로 조사하거나 조작할 수 있는 기능**

- 일반적으로 컴파일 타임에 결정되는 구조를, **런타임에 제어**
- **프레임워크 개발**, **의존성 주입(DI)**, **애노테이션 처리**, **직렬화**, **테스트**, **ORM(JPA)** 등에 핵심적으로 사용됨

------

### 🟨 2. 핵심 클래스들 (`java.lang.reflect` 패키지)

| 클래스        | 설명                                       |
| ------------- | ------------------------------------------ |
| `Class<?>`    | 클래스 정보의 루트. 메타데이터 접근에 사용 |
| `Field`       | 멤버 변수에 대한 정보                      |
| `Method`      | 메서드에 대한 정보                         |
| `Constructor` | 생성자에 대한 정보                         |
| `Modifier`    | 접근 제어자 정보 분석                      |
| `Parameter`   | 매개변수 정보                              |

------

### 🟩 3. Class 객체 획득 방법

```
Class<?> clazz1 = Class.forName("com.example.MyClass"); // 완전한 경로
Class<?> clazz2 = MyClass.class;
MyClass obj = new MyClass();
Class<?> clazz3 = obj.getClass();
```

------

### 🟧 4. 필드(Field) 접근

```
Field field = clazz.getDeclaredField("name"); // private도 포함
field.setAccessible(true); // 접근 허용
field.set(obj, "NewValue"); // 값 설정
System.out.println(field.get(obj)); // 값 조회
```

- `getFields()` : public만
- `getDeclaredFields()` : private 포함

------

### 🟥 5. 메서드(Method) 접근

```
Method method = clazz.getDeclaredMethod("sayHello", String.class);
method.setAccessible(true);
String result = (String) method.invoke(obj, "John");
```

- 오버로딩된 메서드는 정확한 매개변수 타입 명시해야 함
- 리턴값은 Object 타입 → 캐스팅 필요

------

### 🟪 6. 생성자(Constructor) 접근

```
Constructor<MyClass> constructor = MyClass.class.getConstructor(String.class);
MyClass instance = constructor.newInstance("hi");
```

- private 생성자도 `setAccessible(true)`로 접근 가능

------

### 🟨 7. Modifier 클래스 활용

```
int mod = field.getModifiers();
System.out.println(Modifier.isPrivate(mod)); // true
System.out.println(Modifier.isStatic(mod));  // false
```

- 접근 제어자(public, private 등) 및 기타 속성(static, final 등)을 분석할 수 있음

------

### 🟩 8. Parameter 정보

Java 8부터 `-parameters` 옵션을 켜야 이름이 보임

```
for (Parameter p : method.getParameters()) {
    System.out.println(p.getName() + " : " + p.getType());
}
```

------

### 🟧 9. 애노테이션과 리플렉션

```
if (clazz.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation anno = clazz.getAnnotation(MyAnnotation.class);
    System.out.println(anno.value());
}
```

- 메서드, 필드에도 동일하게 사용 가능
- 런타임 유지 정책 (`@Retention(RetentionPolicy.RUNTIME)`) 필수

------

### 🟥 10. 프라이빗 멤버 접근 요약

| 대상   | 접근 방식                                          |
| ------ | -------------------------------------------------- |
| 필드   | `getDeclaredField()` → `setAccessible(true)`       |
| 메서드 | `getDeclaredMethod()` → `setAccessible(true)`      |
| 생성자 | `getDeclaredConstructor()` → `setAccessible(true)` |

------

### 🟪 11. 실무 활용 사례

- **프레임워크 내부**
  - Spring DI: `Field.set()`을 통한 의존성 주입
  - JUnit: `@Test` 메서드 실행
  - JPA: `@Entity` 클래스의 필드 추출 및 매핑
- **라이브러리**
  - Jackson: private 필드 접근하여 JSON 직렬화
  - Lombok: 코드 자동 생성에 리플렉션 활용

------

### 🟨 12. 리플렉션의 단점 및 주의사항

| 단점            | 설명                                           |
| --------------- | ---------------------------------------------- |
| 성능 저하       | 직접 호출보다 느림 (JIT 최적화 우회)           |
| 보안 취약       | private 멤버 조작 가능 (보안 매니저 환경 주의) |
| 유지보수 어려움 | 구조 변경 시 에러 발생 가능성 ↑                |

------

### ✅ 마무리 요약

| 기능        | 메서드                                            |
| ----------- | ------------------------------------------------- |
| 클래스 정보 | `Class.forName()`, `getName()`, `getSuperclass()` |
| 필드        | `getDeclaredFields()`, `field.set/get()`          |
| 메서드      | `getDeclaredMethods()`, `method.invoke()`         |
| 생성자      | `getConstructor()`, `newInstance()`               |
| 접근 허용   | `setAccessible(true)`                             |
| 애노테이션  | `isAnnotationPresent()`, `getAnnotation()`        |

## `javax.xml`, `javax.json`: XML/JSON 처리

### 1.1 DOM (Document Object Model) 방식

> 메모리에 전체 XML 구조를 트리로 로딩 후 조작

#### 🔧 예제: XML 파일 읽기

```
<!-- sample.xml -->
<person>
  <name>John</name>
  <age>30</age>
</person>
```

```
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse(new File("sample.xml"));

Node nameNode = doc.getElementsByTagName("name").item(0);
System.out.println(nameNode.getTextContent()); // John
```

#### 📌 특징

- 읽고 쓰기 모두 가능
- 전체 XML을 메모리에 올림 → **무겁고 느릴 수 있음**
- `org.w3c.dom` API와 함께 사용

------

### 1.2 SAX (Simple API for XML)

> 이벤트 기반 파서, 빠르고 메모리 효율적 (읽기 전용)

```
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser = factory.newSAXParser();

DefaultHandler handler = new DefaultHandler() {
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        System.out.println("Start: " + qName);
    }

    public void characters(char[] ch, int start, int length) {
        System.out.println("Text: " + new String(ch, start, length));
    }

    public void endElement(String uri, String localName, String qName) {
        System.out.println("End: " + qName);
    }
};

parser.parse(new File("sample.xml"), handler);
```

📌 특징:

- **읽기 전용**, 빠름
- 콜백 구조로 구성

------

### 1.3 JAXB (Java Architecture for XML Binding)

> XML ↔ Java 객체 매핑

#### 🔧 예시

```
@XmlRootElement
public class Person {
    public String name;
    public int age;
}
```

```
// Unmarshalling (XML → Object)
JAXBContext ctx = JAXBContext.newInstance(Person.class);
Person p = (Person) ctx.createUnmarshaller().unmarshal(new File("person.xml"));

// Marshalling (Object → XML)
ctx.createMarshaller().marshal(p, System.out);
```

📌 JAXB는 자바 9 이후 `jakarta.xml.bind`로 이전됨

------

### 🟧 2. JSON 처리: `javax.json`

> Java EE 7+ 표준 JSON 처리 API (JSR 353)

------

#### 2.1 JSON 읽기

```
{
  "name": "Alice",
  "age": 25
}
java코드 복사InputStream is = new FileInputStream("data.json");
JsonReader reader = Json.createReader(is);
JsonObject obj = reader.readObject();

System.out.println(obj.getString("name")); // Alice
System.out.println(obj.getInt("age")); // 25
```

- 사용 클래스: `Json`, `JsonReader`, `JsonObject`

------

#### 2.2 JSON 쓰기

```
JsonObject json = Json.createObjectBuilder()
    .add("name", "Bob")
    .add("age", 30)
    .build();

JsonWriter writer = Json.createWriter(new FileOutputStream("output.json"));
writer.writeObject(json);
writer.close();
```

------

#### 2.3 JSON 배열 다루기

```
JsonArray arr = Json.createArrayBuilder()
    .add("apple")
    .add("banana")
    .add("cherry")
    .build();

for (JsonValue value : arr) {
    System.out.println(value.toString());
}
```

------

#### 2.4 주요 인터페이스

| 인터페이스                         | 설명                      |
| ---------------------------------- | ------------------------- |
| `JsonObject`                       | JSON 객체 구조 (Map 유사) |
| `JsonArray`                        | 배열 구조                 |
| `JsonReader`                       | JSON 입력                 |
| `JsonWriter`                       | JSON 출력                 |
| `JsonBuilderFactory`, `JsonParser` | 커스텀 빌더 및 스트리밍   |

------

### 🟥 3. `javax.xml`과 `javax.json` 비교 요약

| 항목              | XML (`javax.xml`) | JSON (`javax.json`)           |
| ----------------- | ----------------- | ----------------------------- |
| 표준 API          | DOM, SAX, JAXB    | JsonObject, JsonReader 등     |
| 사용성            | 복잡하고 구조적   | 간결하고 직관적               |
| 성능              | SAX > DOM > JAXB  | 매우 빠름                     |
| 쓰기              | 지원 (JAXB 등)    | `JsonWriter`, `ObjectBuilder` |
| Java EE 포함 여부 | O                 | Java EE 7+ 이후 포함          |

------

### ✅ 추가로 실무에서는?

- JSON은 `Jackson`, `Gson`, `Moshi` 같은 외부 라이브러리를 더 많이 씀
- XML은 `JAXB`, `DOM4J`, `JAXP`, `StAX`, `XStream` 등이 널리 사용됨

## `java.util.logging`, SLF4J 등 로깅 API

### 🟦 1. 로깅(logging)이란?

> **시스템 실행 중의 상태나 이벤트를 기록**하여 추적, 디버깅, 모니터링 등을 가능하게 하는 방법

- `System.out.println()`보다 효율적이고 유연함
- 로그 수준, 출력 포맷, 대상(파일/콘솔/원격 서버) 등 조절 가능

------

### 🟨 2. `java.util.logging` (JUL: Java Util Logging)

자바 표준에 포함된 기본 로깅 API

#### ✅ 주요 구성 요소

| 구성요소    | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| `Logger`    | 로그를 생성하는 객체                                         |
| `Handler`   | 로그를 출력하는 수단 (콘솔, 파일 등)                         |
| `Formatter` | 로그 출력 형식 지정                                          |
| `Level`     | 로그 수준 (`SEVERE`, `WARNING`, `INFO`, `CONFIG`, `FINE` 등) |

#### 🔧 기본 사용 예시

```
import java.util.logging.*;

public class LoggingExample {
    private static final Logger logger = Logger.getLogger(LoggingExample.class.getName());

    public static void main(String[] args) {
        logger.setLevel(Level.INFO);

        logger.severe("심각한 에러 발생");
        logger.warning("경고 메시지");
        logger.info("정보 메시지");
        logger.fine("디버그 메시지");  // 출력되지 않음 (기본레벨보다 낮음)
    }
}
```

#### 🔧 파일로 로그 저장

```
FileHandler fileHandler = new FileHandler("app.log");
fileHandler.setFormatter(new SimpleFormatter());
logger.addHandler(fileHandler);
```

##### 📌 단점

- 설정이 복잡하고 유연성 부족
- 출력 형식이 제한적
- 실무에선 거의 안 씀

------

### 🟧 3. SLF4J (Simple Logging Facade for Java)

> **로깅 API 추상화 계층** – 로깅 구현체를 바꿔도 코드 수정 없이 사용 가능

#### 🔧 SLF4J는 인터페이스, 구현체는 Logback 또는 Log4j

```
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class App {
    private static final Logger logger = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
        logger.info("시작됨");
        logger.warn("경고");
        logger.error("에러 발생", new RuntimeException("예외"));
    }
}
```

------

### 🟥 4. Logback – SLF4J의 대표 구현체

- 성능, 설정 유연성, XML 기반 구성 지원
- 실무에서 가장 많이 사용됨

#### 🔧 예시: `logback.xml`

```
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>[%d{HH:mm:ss}] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="info">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
```

- `%d`, `%level`, `%logger`, `%msg` 등 포맷 설정 가능
- 로그 파일로도 저장 가능 (`RollingFileAppender`)

------

### 🟪 5. 로그 수준 (공통)

| 레벨  | 의미                        |
| ----- | --------------------------- |
| TRACE | 매우 상세한 정보 (디버깅용) |
| DEBUG | 개발 중 상세 로그           |
| INFO  | 일반적인 실행 흐름 정보     |
| WARN  | 주의가 필요한 상황          |
| ERROR | 예외나 치명적 오류          |

------

### 🟩 6. SLF4J + Logback 설정 구조 요약

1. **의존성 추가 (Maven 예시)**

```
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-api</artifactId>
  <version>1.7.36</version>
</dependency>
<dependency>
  <groupId>ch.qos.logback</groupId>
  <artifactId>logback-classic</artifactId>
  <version>1.2.11</version>
</dependency>
```

1. **코드에서는 SLF4J 인터페이스만 사용**
2. **설정은 `logback.xml`로 분리하여 관리**

------

### 🟨 7. Spring Boot에서 로깅

- 기본 내장: SLF4J + Logback
- `application.yml`이나 `logback-spring.xml`로 설정 가능
- 실시간 로그 레벨 변경 가능 (`/actuator/loggers`)

```
logging:
  level:
    root: INFO
    com.example.myapp: DEBUG
```

------

### ✅ 비교 요약

| 기능           | `java.util.logging` | SLF4J + Logback       |
| -------------- | ------------------- | --------------------- |
| 표준 API 포함  | O                   | X                     |
| 실무 활용      | 드묾                | 매우 많음             |
| 확장성/유연성  | 낮음                | 높음                  |
| 설정 방식      | 코드 기반           | 외부 설정 (XML, YAML) |
| 로그 수준      | 제한적              | 세분화 (TRACE~ERROR)  |
| 포맷/출력 제어 | 제한적              | 매우 유연             |

## 보안 관련: `java.security`, `javax.crypto`

### 🟦 1. `java.security` 패키지 개요

> 자바의 **기본 보안 인프라를 제공**하는 패키지
>  주요 기능: 메시지 다이제스트, 서명, 키 생성, 인증서 처리 등

------

#### 1.1 메시지 다이제스트 (해시 함수)

> 입력 데이터를 일정 길이의 고정된 값으로 변환

```
import java.security.MessageDigest;

MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] hash = md.digest("hello".getBytes());

for (byte b : hash)
    System.out.printf("%02x", b); // SHA-256 해시 출력
```

| 알고리즘 | 설명                           |
| -------- | ------------------------------ |
| MD5      | 빠르지만 취약                  |
| SHA-1    | 더 안전하지만 최근엔 취약 판정 |
| SHA-256  | 현재 실무에서도 많이 사용      |

------

#### 1.2 키 생성과 서명

> 개인키로 서명 → 공개키로 검증

```
// 키 쌍 생성
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
KeyPair pair = keyGen.generateKeyPair();

// 서명
Signature signature = Signature.getInstance("SHA256withRSA");
signature.initSign(pair.getPrivate());
signature.update("message".getBytes());
byte[] signedData = signature.sign();

// 검증
signature.initVerify(pair.getPublic());
signature.update("message".getBytes());
boolean valid = signature.verify(signedData);
System.out.println("서명 검증 결과: " + valid);
```

------

#### 1.3 인증서 및 키스토어

> 인증서 파일(`.cer`, `.jks`)을 사용해 공개키 관리

```
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keystore.jks"), "password".toCharArray());
Certificate cert = ks.getCertificate("myalias");
PublicKey publicKey = cert.getPublicKey();
```

------

### 🟧 2. `javax.crypto` 패키지 개요

> 암호화/복호화, 대칭/비대칭 암호화, 패스워드 기반 암호화(PBE) 등을 지원하는 고수준 API

------

#### 2.1 대칭키 암호화 (AES 등)

```
KeyGenerator keyGen = KeyGenerator.getInstance("AES");
keyGen.init(128);
SecretKey secretKey = keyGen.generateKey();

Cipher cipher = Cipher.getInstance("AES");
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
byte[] encrypted = cipher.doFinal("secret".getBytes());

cipher.init(Cipher.DECRYPT_MODE, secretKey);
byte[] decrypted = cipher.doFinal(encrypted);
System.out.println(new String(decrypted)); // secret
```

| 특징              | 내용                           |
| ----------------- | ------------------------------ |
| 속도 빠름         | 대량의 데이터에 적합           |
| 키 분배 문제 존재 | 네트워크상 안전한 키 교환 필요 |

------

#### 2.2 비대칭키 암호화 (RSA)

```
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
KeyPair pair = keyGen.generateKeyPair();

Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.ENCRYPT_MODE, pair.getPublic());
byte[] encrypted = cipher.doFinal("topsecret".getBytes());

cipher.init(Cipher.DECRYPT_MODE, pair.getPrivate());
byte[] decrypted = cipher.doFinal(encrypted);
System.out.println(new String(decrypted)); // topsecret
```

| 특징                | 내용                          |
| ------------------- | ----------------------------- |
| 키 분리 (공개/개인) | 키 분배가 쉽고 안전           |
| 처리 속도 느림      | 대량 데이터 암호화에는 부적합 |

------

#### 2.3 비밀번호 기반 암호화 (PBE)

```
char[] password = "mypassword".toCharArray();
byte[] salt = "12345678".getBytes();

PBEKeySpec spec = new PBEKeySpec(password, salt, 65536, 128);
SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
SecretKey key = skf.generateSecret(spec);

SecretKeySpec aesKey = new SecretKeySpec(key.getEncoded(), "AES");
```

> PBE는 사용자의 패스워드를 기반으로 **암호화용 키를 안전하게 생성**할 때 사용돼.

------

#### 2.4 CBC 모드, IV 사용

> 블록 암호 방식의 보안성을 높이기 위해 초기화 벡터(IV)를 사용

```
IvParameterSpec iv = new IvParameterSpec(new byte[16]); // 무작위 추천
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
```

------

### 🟩 3. 실제 보안 적용 예시

| 시나리오            | API 사용                        |
| ------------------- | ------------------------------- |
| 비밀번호 저장       | `PBKDF2` + Salt + `Base64`      |
| 데이터베이스 암호화 | `AES` 대칭 암호화               |
| 클라이언트 인증     | `RSA` 서명 검증                 |
| 네트워크 암호화     | SSL (보통 `javax.net.ssl` 활용) |
| 파일 서명           | `java.security.Signature`       |

------

### 🟦 보안 API 계층 요약

| API 계층                   | 제공 기능                                 |
| -------------------------- | ----------------------------------------- |
| `java.security`            | 해시, 서명, 키 생성, 인증서, SecureRandom |
| `javax.crypto`             | 암호화/복호화, PBE, Cipher, SecretKey     |
| `javax.net.ssl`            | HTTPS, TLS/SSL 소켓 통신                  |
| `java.security.cert`       | X.509 인증서 처리                         |
| `java.security.spec`       | 키 사양 (KeySpec 등)                      |
| `java.security.interfaces` | RSA/DSA/ECDSA 전용 인터페이스             |

------

### ✅ 마무리 요약

| 기술                | 설명                                    |
| ------------------- | --------------------------------------- |
| MessageDigest       | 단방향 해시 함수                        |
| Signature           | 디지털 서명                             |
| Cipher              | 양방향 암호화 (AES, RSA 등)             |
| KeyStore            | 키와 인증서 저장소                      |
| SecretKey / KeyPair | 대칭/비대칭 키 객체                     |
| PBKDF2              | 비밀번호 기반 키 생성 (안전)            |
| IV                  | CBC 모드 등에서 블록 암호를 더 안전하게 |