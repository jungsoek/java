# 중첩 선언과 익명 객체

## 중첩 클래스

객체 지향 프로그램에서는 클래스 간에 서로 긴밀한 관계를 맺고 상호작용한다. 클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는 것이 좋으나, 특정 클래스만 관계를 맺을 경우에는 중첩 클래스로 선언하는 것이 유지보수에 도움이 되는 경우가 많다.

중첩 클래스(Nested Class)란 클래스 내부에 선언한 클래스를 말하는데, 중첩 클래스를 사용하면 클래스의 멤버를 쉽게 사용할 수 있고 외부에는 중첩 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.

중첩 클래스는 선언하는 위치에 따라 두 가지로 분류된다. 클래스의 멤버로서 선언되는 중첩 클래스를 멤버 클래스라고 하고, 메소드 내부에서 선언되는 중첩 클래스를 로컬 클래스라고 한다.

| 선언 위치에 따른 분류 | 클래스 분류          | 선언 위치                                                    | 객체 생성 조건                                        |
| --------------------- | -------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| 멤버 클래스           | 인스턴스 멤버 클래스 | class A {<br /><br />     class B { ... }<br />}             | A 객체를 생성해야만<br />B 객체를 생성할 수 있음      |
|                       | 정적 멤버 클래스     | class A {<br /><br />     static class B { ... }<br />}      | A 객체를 생성하지 않아도<br />B 객체를 생성할 수 있음 |
| 로컬 클래스           |                      | class A {<br /><br />     void method()<br />     static class B { ... }<br />} | method가 실행할 때만 B 객체를 생성할 수 있음          |

중첩 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트코드 파일(.class)이 별도로 생성된다. 멤버 클래스일 경우 바이트코드 파일의 이름은 다음과 같이 결정된다.

```java
A $ B .class
```

로컬 클래스일 경우에는 다음과 같이 $1이 포함된 바이트코드 파일이 생성된다.

```java
A $1 B .class
```

## 인스턴스 멤버 클래스

인스턴스 멤버 클래스는 다음과 같이 A 클래스의 멤버로 선언된 B 클래스를 말한다.

```java
[public] class A {
    [public | private] class B {
        
    }
}
```

접근 제한자에 따른 인스턴스 멤버 클래스의 접근 범위는 다음과 같다.

| 구분                | 접근 범위                                      |
| ------------------- | ---------------------------------------------- |
| public class B { }  | 다른 패키지에서 B 클래스를 사용할 수 있다.     |
| class B { }         | 같은 패키지에서만 B 클래스를 사용할 수 있다.   |
| private class B { } | A 클래스 내부에서만 B 클래스를 사용할 수 있다. |

인스턴스 멤버 클래스 B는 주로 A 클래스 내부에서 사용되므로 private 접근 제한을 갖는 것이 일반적이다. B 객체는 A 클래스 내부 어디에서나 생성할 수는 없고, 인스턴스 필드값, 생성자, 인스턴스 메소드에서 생성할 수 있다. A 객체가 있어야 B 객체도 생성할 수 있기 때문이다.

*A.java*

```java

```

B 객체를 A 클래스 외부에 생성하려면 default 또는 public 접근 제한을 가져야 하고, A 객체를 먼저 생성한 다음 B 객체를 생성해야 한다.

```java
A a = new A();
A.B b = a.new B();
```

*AExample.java*

```java

```

인스턴스 멤버 클래스 B 내부에는 일반 클래스와 같이 필드, 생성자, 메소드 선언이 올 수 있다. 정적 필드와 정적 메소드는 Java 17부터 선언이 가능하다.

*A.java*

```java

```

*AExample.java*

```java

```

```

```

## 정적 멤버 클래스

정적 멤버 클래스는 다음과 같이 static 키워드와 함께 A 클래스의 멤버로 선언된 B 클래스를 말한다.

```java
[public] class A {
    [public | private] static class B {
        
    }
}
```

접근 제한자에 따른 정적 멤버 클래스의 접근 범위는 다음과 같다.

| 구분                       | 접근 범위                                      |
| -------------------------- | ---------------------------------------------- |
| public static class B { }  | 다른 패키지에서 B 클래스를 사용할 수 있다.     |
| static class B { }         | 같은 패키지에서만 B 클래스를 사용할 수 있다.   |
| private static class B { } | A 클래스 내부에서만 B 클래스를 사용할 수 있다. |

정적 멤버 클래스 B는 A 클래스 내부에서 사용되기도 하지만, A 클래스 외부에서 A와 함께 사용되는 경우가 많기 때문에 주로 default 또는 public 접근 제한을 가진다. B 객체는 A 클래스 내부 어디든 객체를 생성할 수 있다.

*A.java*

```java

```

A 클래스 외부에서 B 객체를 생성하려면 A 객체 생성 없이 A 클래스로 접근해서 B 객체를 생성할 수 있다.

```java
A.B b = new A.B();
```

*AExample.java*

```java

```

정적 멤버 클래스 B 내부에는 일반 클래스와 같이 필드, 생성자, 메소드 선언이 올 수 있다.

*A.java*

```java

```

*AExample.java*

```java

```

```

```

## 로컬 클래스

생성자 또는 메소드 내부에서 다음과 같이 선언된 클래스를 로컬 클래스라고 한다.

```java
[public] class A {
    // 생성자
    public A() {
        class B { }
    }
    
    // 메소드
    public void method() {
        class B { }
    }
}
```

로컬 클래스는 생성자와 메소드가 실행될 동안에만 객체를 생성할 수 있다.

*A.java*

```java

```

로컬 클래스 B 내부에는 일반 클래스와 같이 필드, 생성자, 메소드 선언이 올 수 있다. 정적 필드와 정적 메소드는 Java 17부터 선언이 가능하다.

*A.java*

```java

```

*AExample.java*

```java

```

```

```

로컬 변수(생성자 또는 메소드의 매개변수 또는 내부에서 선언된 변수)를 로컬 클래스에서 사용할 경우 로컬 변수는 final 특성을 갖게 되므로 값을 읽을 수만 있고 수정할 수 없게 된다. 이것은 로컬 클래스 내부에서 값을 변경하지 못하도록 제한하기 때문이다.

Java 8 이후부터는 명시적으로 final 키워드를 붙이지 않아도 되지만, 로컬 변수에 final 키워드를 추가해서 final 변수임을 명확히 할 수도 있다. 참고로 Java 7 이전에는 final 키워드를 반드시 붙여야 했다.

*A.java*

```java

```

## 바깥 멤버 접근

중첩 클래스는 바깥 클래스와 긴밀한 관계를 맺으면서 바깥 클래스의 멤버(필드, 메소드)에 접근할 수 있다. 하지만 중첩 클래스가 어떻게 선언되었느냐에 따라 접근 제한이 있을 수 있다.

### 바깥 클래스의 멤버 접근 제한

정적 멤버 클래스 내부에서는 바깥 클래스의 필드와 메소드를 사용할 때 제한이 따른다.

| 구분                 | 바깥 클래스의 사용 가능한 멤버        |
| -------------------- | ------------------------------------- |
| 인스턴스 멤버 클래스 | 바깥 클래스의 모든 필드와 메소드      |
| 정적 멤버 클래스     | 바깥 클래스의 정적 필드와 정적 메소드 |

정적 멤버 클래스는 바깥 객체가 없어도 사용 가능해야 하므로 바깥 클래스의 인스턴스 필드와 인스턴스 메소드는 사용하지 못한다.

*A.java*

```java

```

### 바깥 클래스의 객체 접근

중첩 클래스 내부에서 this는 해당 중첩 클래스의 객체를 말한다. 만약 중첩 클래스 내부에서 바깥 클래스의 객체를 얻으려면 바깥 클래스 이름에 this를 붙여주면 된다.

```java
바깥클래스이름.this => 바깥 객체
```

다음 예제는 중첩 클래스와 바깥 클래스가 동일한 이름의 인스턴스 필드와 메소드를 가지고 있을 경우, 바깥 객체 소속의 필드와 메소드를 사용하는 방법을 보여준다.

*A.java*

```java

```

*AExample.java*

```java

```

```

```

## 중첩 인터페이스

중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다. 인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 객체를 만들기 위해서이다. 중첩 인터페이스는 다음과 같이 선언된다.

```java
class A {
    [public | private] [static] interface B {
        // 상수 필드
        // 추상 메소드
        // 디폴트 메소드
        // 정적 메소드
    }
}
```

외부의 접근을 막지 않으려면 public을 붙이고, A 클래스 내부에서만 사용하려면 private을 붙인다. 접근 제한자를 붙이지 않으면 같은 패키지 안에서만 접근이 가능하다. 그리고 A 객체 없이 B 인터페이스를 사용할 수 있도록 하기 위해 static을 추가할 수 있다.

중첩 인터페이스는 안드로이드와 같은 UI 프로그램에서 이벤트를 처리할 목적으로 많이 활용된다. 예를 들어 버튼을 클릭했을 때 이벤트를 처리할 객체는 중첩 인터페이스를 구현해서 만든다. 다음 예제를 따라 작성하면서 이해해보자.

*Button.java*

```java

```

외부에서 접근이 가능하도록 public이면서 Button 객체 없이 사용할 수 있는 static 중첩 인터페이스로 ClickListener를 선언했다. 그리고 추상 메소드인 onClick()을 선언했다. onClick() 메소드는 버튼이 클릭되었을 때 호출될 메소드이다.

Button 클래스에 ClickListener 타입의 필드와 Setter를 추가해서 외부에서 Setter를 통해 ClickListener 구현 객체를 필드에 저장할 수 있도록 하자.

*Button.java*

```java

```

Button이 클릭되었을 때 실행할 메소드로 click()을 다음과 같이 추가한다. 실행 내용은 ClickListener 인터페이스 필드를 이용해서 onClick() 추상 메소드를 호출한다.

*Button.java*

```java

```

11라인의 ClickListener 필드는 14라인에서 Setter를 통해 제공된 ClickListener 구현 객체의 참조를 갖고 있다. 따라서 19라인에서 onClick() 메소드를 호출하면 ClickListener 구현 객체의 onClick() 메소드가 실행된다. 이제 버튼을 이용하는 실행 클래스를 작성해보자.

*ButtonExample.java*

```java

```

```

```

버튼 이벤트를 처리할 ClickListener 구현 클래스로, onClick() 메소드를 재정의해서 버튼이 클릭되었을 때 해야할 일을 코딩한다. 버튼이 앞으로 클릭되었을 때 처리를 담당할 ClickListener 구현 객체를 설정하는 코드이다.

UI 프로그램에서는 마우스로 버튼을 클릭하지만, 이 예제는 click() 메소드를 호출하였다. 이 메소드가 호출되면 버튼에 설정된 ClickListener 구현 객체의 onClick() 메소드가 실행된다. 버튼에 어떤 ClickListener 구현 객체가 설정되었느냐에 따라 실행 결과는 달라진다(다형성).

## 익명 객체

익명(anonymous)객체는 이름이 없는 객체를 말한다. 명시적으로 클래스를 선언하지 않기 때문에 쉽게 객체를 생성할 수 있다는 장점이 있다. 익명 객체는 필드값, 로컬 변수값, 매개변수값으로 주로 사용된다.

익명 객체는 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. 클래스를 상속해서 만들 경우 익명 자식 객체라고 하고, 인터페이스를 구현해서 만들 경우 익명 구현 객체라고 한다.

### 익명 자식 객체

익명 자식 객체는 부모 클래스를 상속받아 다음과 같이 생성된다. 이렇게 생성된 객체는 부모 타입의 필드, 로컬 변수, 매개변수의 값으로 대입할 수 있다.

```java
new 부모생성자(매개값, ...) {
    // 필드
    // 메소드
}
```

중괄호 블록 안의 필드와 메소드는 익명 자식 객체가 가져야 할 멤버로, 중괄호 블록 안에서만 사용할 수 있다. 익명 자식 객체는 부모 타입에 태입되므로 부모 타입에 선언된 멤버만 접근할 수 있기 때문이다. 중괄호 블록 안에는 주로 부모 메소드를 재정의하는 코드가 온다.

다음 예제는 Tire 클래스의 익명 자식 객체를 생성해서 필드, 로컬 변수, 매개변수의 값으로 사용하는 방법을 보여준다. Tire 클래스는 roll() 메소드를 가지고 있지만, 익명 자식 객체는 roll()을 재정의해 실행 내용을 변경한다(다형성).

*Tire.java*

```java

```

*Car.java*

```java

```

*CarExample.java*

```java

```

```

```

익명 자식 객체가 부모 타입에 대입되면 부모 메소드 roll()을 호출할 경우, 재정의된 익명 자식 객체의 roll() 메소드가 실행되는 것을 볼 수 있다(다형성).

### 익명 구현 객체

익명 구현 객체는 인터페이스를 구현해서 다음과 같이 생성된다. 이렇게 생성된 객체는 인터페이스 타입의 필드, 로컬변수, 매개변수의 값으로 대입할 수 있다. 익명 구현 객체는 안드로이드와 같은 UI 프로그램에서 이벤트를 처리하는 객체로 많이 사용된다.

```java
new 인터페이스() {
    // 필드
    // 메소드
}
```

중괄호 블록 안의 필드와 메소드는 익명 구현 객체가 가져야 할 멤버로, 중괄호 블록 안에서만 사용할 수 있다. 그 이유는 익명 구현 객체는 인터페이스 타입에 대입되므로 인터페이스 타입에 선언된 멤버만 접근할 수 있기 때문이다. 중괄호 블록 안에는 주로 인터페이스의 추상 메소드를 재정의하는 코드가 온다.

다음 예제는 RemoteControl 인터페이스의 익명 구현 객체를 생성해서 필드, 로컬 변수, 매개변수 값으로 사용하는 방법을 보여준다. 익명 구현 객체는 roll() 메소드를 재정의해서 실행 내용을 가지고 있다(다형성).

*RemoteControl.java*

```java

```

*Home.java*

```java

```

*HomeExample.java*

```java

```

```

```

다음 예제는 중첩 인터페이스의 예제를 수정한 것으로, 버튼 이벤트 처리 객체를 익명 구현 객체로 대체한 것이다. Setter를 호출할 때 매개값으로 ClickListener 익명 구현 객체를 대입했다. 명시적인 구현 클래스를 생성하지 않기 때문에 코드가 간결해진 것을 볼 수 있다.

*ButtonExample.java*

```java

```

```

```

